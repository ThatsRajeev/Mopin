/**
 * Cashfree Payment Gateway APIs
 * Cashfree\'s Payment Gateway APIs provide developers with a streamlined pathway to integrate advanced payment processing capabilities into their applications, platforms and websites.
 *
 * The version of the OpenAPI document: 2023-08-01
 * Contact: developers@cashfree.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import type { AxiosInstance, AxiosRequestConfig } from 'axios';
import { CFEnvironment } from './configuration';
/**
 * Error at cashfree\'s server
 * @export
 * @interface ApiError
 */
export interface ApiError {
    /**
     *
     * @type {string}
     * @memberof ApiError
     */
    'message'?: string;
    /**
     *
     * @type {string}
     * @memberof ApiError
     */
    'code'?: string;
    /**
     * api_error
     * @type {string}
     * @memberof ApiError
     */
    'type'?: ApiErrorTypeEnum;
}
export declare const ApiErrorTypeEnum: {
    readonly API_ERROR: "api_error";
    readonly UNKNOWN_DEFAULT_OPEN_API: "11184809";
};
export type ApiErrorTypeEnum = typeof ApiErrorTypeEnum[keyof typeof ApiErrorTypeEnum];
/**
 * Error when resource requested is not found
 * @export
 * @interface ApiError404
 */
export interface ApiError404 {
    /**
     *
     * @type {string}
     * @memberof ApiError404
     */
    'message'?: string;
    /**
     *
     * @type {string}
     * @memberof ApiError404
     */
    'code'?: string;
    /**
     * invalid_request_error
     * @type {string}
     * @memberof ApiError404
     */
    'type'?: ApiError404TypeEnum;
}
export declare const ApiError404TypeEnum: {
    readonly INVALID_REQUEST_ERROR: "invalid_request_error";
    readonly UNKNOWN_DEFAULT_OPEN_API: "11184809";
};
export type ApiError404TypeEnum = typeof ApiError404TypeEnum[keyof typeof ApiError404TypeEnum];
/**
 * duplicate request
 * @export
 * @interface ApiError409
 */
export interface ApiError409 {
    /**
     *
     * @type {string}
     * @memberof ApiError409
     */
    'message'?: string;
    /**
     *
     * @type {string}
     * @memberof ApiError409
     */
    'code'?: string;
    /**
     * invalid_request_error
     * @type {string}
     * @memberof ApiError409
     */
    'type'?: ApiError409TypeEnum;
}
export declare const ApiError409TypeEnum: {
    readonly INVALID_REQUEST_ERROR: "invalid_request_error";
    readonly UNKNOWN_DEFAULT_OPEN_API: "11184809";
};
export type ApiError409TypeEnum = typeof ApiError409TypeEnum[keyof typeof ApiError409TypeEnum];
/**
 * Error when there is error at partner bank
 * @export
 * @interface ApiError502
 */
export interface ApiError502 {
    /**
     *
     * @type {string}
     * @memberof ApiError502
     */
    'message'?: string;
    /**
     * `bank_processing_failure` will be returned here to denote failure at bank.
     * @type {string}
     * @memberof ApiError502
     */
    'code'?: string;
    /**
     * api_error
     * @type {string}
     * @memberof ApiError502
     */
    'type'?: ApiError502TypeEnum;
}
export declare const ApiError502TypeEnum: {
    readonly API_ERROR: "api_error";
    readonly UNKNOWN_DEFAULT_OPEN_API: "11184809";
};
export type ApiError502TypeEnum = typeof ApiError502TypeEnum[keyof typeof ApiError502TypeEnum];
/**
 * App payment method
 * @export
 * @interface App
 */
export interface App {
    /**
     * Specify the channel through which the payment must be processed.
     * @type {string}
     * @memberof App
     */
    'channel': string;
    /**
     * Specify the provider through which the payment must be processed.
     * @type {string}
     * @memberof App
     */
    'provider': AppProviderEnum;
    /**
     * Customer phone number associated with a wallet for payment.
     * @type {string}
     * @memberof App
     */
    'phone': string;
}
export declare const AppProviderEnum: {
    readonly GPAY: "gpay";
    readonly PHONEPE: "phonepe";
    readonly OLA: "ola";
    readonly PAYTM: "paytm";
    readonly AMAZON: "amazon";
    readonly AIRTEL: "airtel";
    readonly FREECHARGE: "freecharge";
    readonly MOBIKWIK: "mobikwik";
    readonly JIO: "jio";
    readonly UNKNOWN_DEFAULT_OPEN_API: "11184809";
};
export type AppProviderEnum = typeof AppProviderEnum[keyof typeof AppProviderEnum];
/**
 * App payment method
 * @export
 * @interface AppPaymentMethod
 */
export interface AppPaymentMethod {
    /**
     *
     * @type {App}
     * @memberof AppPaymentMethod
     */
    'app': App;
}
/**
 * Error if api keys are wrong
 * @export
 * @interface AuthenticationError
 */
export interface AuthenticationError {
    /**
     *
     * @type {string}
     * @memberof AuthenticationError
     */
    'message'?: string;
    /**
     *
     * @type {string}
     * @memberof AuthenticationError
     */
    'code'?: string;
    /**
     * authentication_error
     * @type {string}
     * @memberof AuthenticationError
     */
    'type'?: string;
}
/**
 * If preauth enabled for account you will get this body
 * @export
 * @interface AuthorizationInPaymentsEntity
 */
export interface AuthorizationInPaymentsEntity {
    /**
     * One of CAPTURE or VOID
     * @type {string}
     * @memberof AuthorizationInPaymentsEntity
     */
    'action'?: AuthorizationInPaymentsEntityActionEnum;
    /**
     * One of SUCCESS or PENDING
     * @type {string}
     * @memberof AuthorizationInPaymentsEntity
     */
    'status'?: AuthorizationInPaymentsEntityStatusEnum;
    /**
     * The captured amount for this authorization request
     * @type {number}
     * @memberof AuthorizationInPaymentsEntity
     */
    'captured_amount'?: number;
    /**
     * Start time of this authorization hold (only for UPI)
     * @type {string}
     * @memberof AuthorizationInPaymentsEntity
     */
    'start_time'?: string;
    /**
     * End time of this authorization hold (only for UPI)
     * @type {string}
     * @memberof AuthorizationInPaymentsEntity
     */
    'end_time'?: string;
    /**
     * Approve by time as passed in the authorization request (only for UPI)
     * @type {string}
     * @memberof AuthorizationInPaymentsEntity
     */
    'approve_by'?: string;
    /**
     * CAPTURE or VOID reference number based on action
     * @type {string}
     * @memberof AuthorizationInPaymentsEntity
     */
    'action_reference'?: string;
    /**
     * Time of action (CAPTURE or VOID)
     * @type {string}
     * @memberof AuthorizationInPaymentsEntity
     */
    'action_time'?: string;
}
export declare const AuthorizationInPaymentsEntityActionEnum: {
    readonly CAPTURE: "CAPTURE";
    readonly VOID: "VOID";
    readonly UNKNOWN_DEFAULT_OPEN_API: "11184809";
};
export type AuthorizationInPaymentsEntityActionEnum = typeof AuthorizationInPaymentsEntityActionEnum[keyof typeof AuthorizationInPaymentsEntityActionEnum];
export declare const AuthorizationInPaymentsEntityStatusEnum: {
    readonly SUCCESS: "SUCCESS";
    readonly PENDING: "PENDING";
    readonly UNKNOWN_DEFAULT_OPEN_API: "11184809";
};
export type AuthorizationInPaymentsEntityStatusEnum = typeof AuthorizationInPaymentsEntityStatusEnum[keyof typeof AuthorizationInPaymentsEntityStatusEnum];
/**
 * Request to capture or void transaction
 * @export
 * @interface AuthorizeOrderRequest
 */
export interface AuthorizeOrderRequest {
    /**
     * Type of authorization to run. Can be one of \'CAPTURE\' , \'VOID\'
     * @type {string}
     * @memberof AuthorizeOrderRequest
     */
    'action'?: AuthorizeOrderRequestActionEnum;
    /**
     * The amount if you are running a \'CAPTURE\'
     * @type {number}
     * @memberof AuthorizeOrderRequest
     */
    'amount'?: number;
}
export declare const AuthorizeOrderRequestActionEnum: {
    readonly CAPTURE: "CAPTURE";
    readonly VOID: "VOID";
    readonly UNKNOWN_DEFAULT_OPEN_API: "11184809";
};
export type AuthorizeOrderRequestActionEnum = typeof AuthorizeOrderRequestActionEnum[keyof typeof AuthorizeOrderRequestActionEnum];
/**
 * Invalid request received from client
 * @export
 * @interface BadRequestError
 */
export interface BadRequestError {
    /**
     *
     * @type {string}
     * @memberof BadRequestError
     */
    'message'?: string;
    /**
     *
     * @type {string}
     * @memberof BadRequestError
     */
    'code'?: string;
    /**
     *
     * @type {string}
     * @memberof BadRequestError
     */
    'type'?: BadRequestErrorTypeEnum;
}
export declare const BadRequestErrorTypeEnum: {
    readonly INVALID_REQUEST_ERROR: "invalid_request_error";
    readonly UNKNOWN_DEFAULT_OPEN_API: "11184809";
};
export type BadRequestErrorTypeEnum = typeof BadRequestErrorTypeEnum[keyof typeof BadRequestErrorTypeEnum];
/**
 * Card Payment method
 * @export
 * @interface Card
 */
export interface Card {
    /**
     * The channel for card payments can be \"link\" or \"post\". Post is used for seamless OTP payments where merchant captures OTP on their own page.
     * @type {string}
     * @memberof Card
     */
    'channel': CardChannelEnum;
    /**
     * Customer card number for plain card transactions. Token pan number for tokenized card transactions.
     * @type {string}
     * @memberof Card
     */
    'card_number'?: string;
    /**
     * Customer name mentioned on the card.
     * @type {string}
     * @memberof Card
     */
    'card_holder_name'?: string;
    /**
     * Card expiry month for plain card transactions. Token expiry month for tokenized card transactions.
     * @type {string}
     * @memberof Card
     */
    'card_expiry_mm'?: string;
    /**
     * Card expiry year for plain card transactions. Token expiry year for tokenized card transactions.
     * @type {string}
     * @memberof Card
     */
    'card_expiry_yy'?: string;
    /**
     * CVV mentioned on the card.
     * @type {string}
     * @memberof Card
     */
    'card_cvv'?: string;
    /**
     * instrument id of saved card. Required only to make payment using saved instrument.
     * @type {string}
     * @memberof Card
     */
    'instrument_id'?: string;
    /**
     * cryptogram received from card network. Required only for tokenized card transactions.
     * @type {string}
     * @memberof Card
     */
    'cryptogram'?: string;
    /**
     * TRID issued by card networks. Required only for tokenized card transactions.
     * @type {string}
     * @memberof Card
     */
    'token_requestor_id'?: string;
    /**
     *
     * @type {string}
     * @memberof Card
     */
    'token_type'?: CardTokenTypeEnum;
    /**
     * last 4 digits of original card number. Required only for tokenized card transactions.
     * @type {string}
     * @memberof Card
     */
    'card_display'?: string;
    /**
     * Card alias as returned by Cashfree Vault API.
     * @type {string}
     * @memberof Card
     */
    'card_alias'?: string;
    /**
     * One of [\"Kotak\", \"ICICI\", \"RBL\", \"BOB\", \"Standard Chartered\"]. Card bank name, required for EMI payments. This is the bank user has selected for EMI
     * @type {string}
     * @memberof Card
     */
    'card_bank_name'?: CardCardBankNameEnum;
    /**
     * EMI tenure selected by the user
     * @type {number}
     * @memberof Card
     */
    'emi_tenure'?: number;
}
export declare const CardChannelEnum: {
    readonly LINK: "link";
    readonly POST: "post";
    readonly UNKNOWN_DEFAULT_OPEN_API: "11184809";
};
export type CardChannelEnum = typeof CardChannelEnum[keyof typeof CardChannelEnum];
export declare const CardTokenTypeEnum: {
    readonly ISSUER_TOKEN: "ISSUER_TOKEN";
    readonly NETWORK_GC_TOKEN: "NETWORK_GC_TOKEN";
    readonly ISSUER_GC_TOKEN: "ISSUER_GC_TOKEN";
    readonly UNKNOWN_DEFAULT_OPEN_API: "11184809";
};
export type CardTokenTypeEnum = typeof CardTokenTypeEnum[keyof typeof CardTokenTypeEnum];
export declare const CardCardBankNameEnum: {
    readonly KOTAK: "Kotak";
    readonly ICICI: "ICICI";
    readonly RBL: "RBL";
    readonly BOB: "BOB";
    readonly STANDARD_CHARTERED: "Standard Chartered";
    readonly UNKNOWN_DEFAULT_OPEN_API: "11184809";
};
export type CardCardBankNameEnum = typeof CardCardBankNameEnum[keyof typeof CardCardBankNameEnum];
/**
 * Payment method for card emi
 * @export
 * @interface CardEMI
 */
export interface CardEMI {
    /**
     * The channel for card payments will always be \"link\"
     * @type {string}
     * @memberof CardEMI
     */
    'channel': string;
    /**
     * Customer card number.
     * @type {string}
     * @memberof CardEMI
     */
    'card_number': string;
    /**
     * Customer name mentioned on the card.
     * @type {string}
     * @memberof CardEMI
     */
    'card_holder_name'?: string;
    /**
     * Card expiry month.
     * @type {string}
     * @memberof CardEMI
     */
    'card_expiry_mm': string;
    /**
     * Card expiry year.
     * @type {string}
     * @memberof CardEMI
     */
    'card_expiry_yy': string;
    /**
     * CVV mentioned on the card.
     * @type {string}
     * @memberof CardEMI
     */
    'card_cvv': string;
    /**
     * Card alias as returned by Cashfree Vault API
     * @type {string}
     * @memberof CardEMI
     */
    'card_alias'?: string;
    /**
     * Card bank name, required for EMI payments. This is the bank user has selected for EMI. One of [\"hdfc, \"kotak\", \"icici\", \"rbl\", \"bob\", \"standard chartered\", \"axis\", \"au\", \"yes\", \"sbi\", \"fed\", \"hsbc\", \"citi\", \"amex\"]
     * @type {string}
     * @memberof CardEMI
     */
    'card_bank_name': CardEMICardBankNameEnum;
    /**
     * EMI tenure selected by the user
     * @type {number}
     * @memberof CardEMI
     */
    'emi_tenure': number;
}
export declare const CardEMICardBankNameEnum: {
    readonly HDFC: "hdfc";
    readonly KOTAK: "kotak";
    readonly ICICI: "icici";
    readonly RBL: "rbl";
    readonly BOB: "bob";
    readonly STANDARD_CHARTERED: "standard chartered";
    readonly AXIS: "axis";
    readonly AU: "au";
    readonly YES: "yes";
    readonly SBI: "sbi";
    readonly FED: "fed";
    readonly HSBC: "hsbc";
    readonly CITI: "citi";
    readonly AMEX: "amex";
    readonly UNKNOWN_DEFAULT_OPEN_API: "11184809";
};
export type CardEMICardBankNameEnum = typeof CardEMICardBankNameEnum[keyof typeof CardEMICardBankNameEnum];
/**
 * Complete card emi payment method
 * @export
 * @interface CardEMIPaymentMethod
 */
export interface CardEMIPaymentMethod {
    /**
     *
     * @type {CardEMI}
     * @memberof CardEMIPaymentMethod
     */
    'emi': CardEMI;
}
/**
 *
 * @export
 * @interface CardOffer
 */
export interface CardOffer {
    /**
     *
     * @type {Array<string>}
     * @memberof CardOffer
     */
    'type': Array<string>;
    /**
     * Bank Name of Card.
     * @type {string}
     * @memberof CardOffer
     */
    'bank_name': string;
    /**
     *
     * @type {Array<string>}
     * @memberof CardOffer
     */
    'scheme_name': Array<string>;
}
/**
 * The card payment object is used to make payment using either plain card number, saved card instrument id or using cryptogram
 * @export
 * @interface CardPaymentMethod
 */
export interface CardPaymentMethod {
    /**
     *
     * @type {Card}
     * @memberof CardPaymentMethod
     */
    'card': Card;
}
/**
 * Request body for cardless emi payment method
 * @export
 * @interface CardlessEMI
 */
export interface CardlessEMI {
    /**
     * The channel for cardless EMI is always `link`
     * @type {string}
     * @memberof CardlessEMI
     */
    'channel'?: string;
    /**
     * One of [`flexmoney`, `zestmoney`, `hdfc`, `icici`, `cashe`, `idfc`, `kotak`]
     * @type {string}
     * @memberof CardlessEMI
     */
    'provider'?: CardlessEMIProviderEnum;
    /**
     * Customers phone number for this payment instrument. If the customer is not eligible you will receive a 400 error with type as \'invalid_request_error\' and code as \'invalid_request_error\'
     * @type {string}
     * @memberof CardlessEMI
     */
    'phone'?: string;
    /**
     * EMI tenure for the selected provider. This is mandatory when provider is one of [`hdfc`, `icici`, `cashe`, `idfc`, `kotak`]
     * @type {number}
     * @memberof CardlessEMI
     */
    'emi_tenure'?: number;
}
export declare const CardlessEMIProviderEnum: {
    readonly FLEXMONEY: "flexmoney";
    readonly ZESTMONEY: "zestmoney";
    readonly HDFC: "hdfc";
    readonly ICICI: "icici";
    readonly CASHE: "cashe";
    readonly IDFC: "idfc";
    readonly KOTAK: "kotak";
    readonly UNKNOWN_DEFAULT_OPEN_API: "11184809";
};
export type CardlessEMIProviderEnum = typeof CardlessEMIProviderEnum[keyof typeof CardlessEMIProviderEnum];
/**
 * cardless EMI object
 * @export
 * @interface CardlessEMIEntity
 */
export interface CardlessEMIEntity {
    /**
     *
     * @type {string}
     * @memberof CardlessEMIEntity
     */
    'payment_method'?: string;
    /**
     *
     * @type {Array<EMIPlansArray>}
     * @memberof CardlessEMIEntity
     */
    'emi_plans'?: Array<EMIPlansArray>;
}
/**
 * cardless EMI payment method object
 * @export
 * @interface CardlessEMIPaymentMethod
 */
export interface CardlessEMIPaymentMethod {
    /**
     *
     * @type {CardlessEMI}
     * @memberof CardlessEMIPaymentMethod
     */
    'cardless_emi': CardlessEMI;
}
/**
 * cardless EMI query object
 * @export
 * @interface CardlessEMIQueries
 */
export interface CardlessEMIQueries {
    /**
     * OrderId of the order. Either of `order_id` or `amount` is mandatory.
     * @type {string}
     * @memberof CardlessEMIQueries
     */
    'order_id'?: string;
    /**
     * Amount of the order. OrderId of the order. Either of `order_id` or `amount` is mandatory.
     * @type {number}
     * @memberof CardlessEMIQueries
     */
    'amount'?: number;
    /**
     *
     * @type {CustomerDetailsCardlessEMI}
     * @memberof CardlessEMIQueries
     */
    'customer_details'?: CustomerDetailsCardlessEMI;
}
/**
 * Cashback detail boject
 * @export
 * @interface CashbackDetails
 */
export interface CashbackDetails {
    /**
     * Type of discount
     * @type {string}
     * @memberof CashbackDetails
     */
    'cashback_type': CashbackDetailsCashbackTypeEnum;
    /**
     * Value of Discount.
     * @type {number}
     * @memberof CashbackDetails
     */
    'cashback_value': number;
    /**
     * Maximum Value of Cashback allowed.
     * @type {number}
     * @memberof CashbackDetails
     */
    'max_cashback_amount': number;
}
export declare const CashbackDetailsCashbackTypeEnum: {
    readonly FLAT: "flat";
    readonly PERCENTAGE: "percentage";
    readonly UNKNOWN_DEFAULT_OPEN_API: "11184809";
};
export type CashbackDetailsCashbackTypeEnum = typeof CashbackDetailsCashbackTypeEnum[keyof typeof CashbackDetailsCashbackTypeEnum];
/**
 * Request body to create a customer at cashfree
 * @export
 * @interface CreateCustomerRequest
 */
export interface CreateCustomerRequest {
    /**
     * Customer Phone Number
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'customer_phone': string;
    /**
     * Customer Email
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'customer_email'?: string;
    /**
     * Customer Name
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'customer_name'?: string;
}
/**
 * Request paramenters for link creation
 * @export
 * @interface CreateLinkRequest
 */
export interface CreateLinkRequest {
    /**
     * Unique Identifier (provided by merchant) for the Link. Alphanumeric and only - and _ allowed (50 character limit). Use this for other link-related APIs.
     * @type {string}
     * @memberof CreateLinkRequest
     */
    'link_id': string;
    /**
     * Amount to be collected using this link. Provide upto two decimals for paise.
     * @type {number}
     * @memberof CreateLinkRequest
     */
    'link_amount': number;
    /**
     * Currency for the payment link. Default is INR. Contact care@cashfree.com to enable new currencies.
     * @type {string}
     * @memberof CreateLinkRequest
     */
    'link_currency': string;
    /**
     * A brief description for which payment must be collected. This is shown to the customer.
     * @type {string}
     * @memberof CreateLinkRequest
     */
    'link_purpose': string;
    /**
     *
     * @type {LinkCustomerDetailsEntity}
     * @memberof CreateLinkRequest
     */
    'customer_details': LinkCustomerDetailsEntity;
    /**
     * If \"true\", customer can make partial payments for the link.
     * @type {boolean}
     * @memberof CreateLinkRequest
     */
    'link_partial_payments'?: boolean;
    /**
     * Minimum amount in first installment that needs to be paid by the customer if partial payments are enabled. This should be less than the link_amount.
     * @type {number}
     * @memberof CreateLinkRequest
     */
    'link_minimum_partial_amount'?: number;
    /**
     * Time after which the link expires. Customers will not be able to make the payment beyond the time specified here. You can provide them in a valid ISO 8601 time format. Default is 30 days.
     * @type {string}
     * @memberof CreateLinkRequest
     */
    'link_expiry_time'?: string;
    /**
     *
     * @type {LinkNotifyEntity}
     * @memberof CreateLinkRequest
     */
    'link_notify'?: LinkNotifyEntity;
    /**
     * If \"true\", reminders will be sent to customers for collecting payments.
     * @type {boolean}
     * @memberof CreateLinkRequest
     */
    'link_auto_reminders'?: boolean;
    /**
     * Key-value pair that can be used to store additional information about the entity. Maximum 5 key-value pairs
     * @type {{ [key: string]: string; }}
     * @memberof CreateLinkRequest
     */
    'link_notes'?: {
        [key: string]: string;
    };
    /**
     *
     * @type {LinkMetaResponseEntity}
     * @memberof CreateLinkRequest
     */
    'link_meta'?: LinkMetaResponseEntity;
}
/**
 * create offer backend request object
 * @export
 * @interface CreateOfferRequest
 */
export interface CreateOfferRequest {
    /**
     *
     * @type {OfferMeta}
     * @memberof CreateOfferRequest
     */
    'offer_meta': OfferMeta;
    /**
     *
     * @type {OfferTnc}
     * @memberof CreateOfferRequest
     */
    'offer_tnc': OfferTnc;
    /**
     *
     * @type {OfferDetails}
     * @memberof CreateOfferRequest
     */
    'offer_details': OfferDetails;
    /**
     *
     * @type {OfferValidations}
     * @memberof CreateOfferRequest
     */
    'offer_validations': OfferValidations;
}
/**
 * Request body to create an order at cashfree
 * @export
 * @interface CreateOrderRequest
 */
export interface CreateOrderRequest {
    /**
     * Order identifier present in your system. Alphanumeric, \'_\' and \'-\' only
     * @type {string}
     * @memberof CreateOrderRequest
     */
    'order_id'?: string;
    /**
     * Bill amount for the order. Provide upto two decimals. 10.15 means Rs 10 and 15 paisa
     * @type {number}
     * @memberof CreateOrderRequest
     */
    'order_amount': number;
    /**
     * Currency for the order. INR if left empty. Contact care@cashfree.com to enable new currencies.
     * @type {string}
     * @memberof CreateOrderRequest
     */
    'order_currency': string;
    /**
     *
     * @type {CustomerDetails}
     * @memberof CreateOrderRequest
     */
    'customer_details': CustomerDetails;
    /**
     *
     * @type {TerminalDetails}
     * @memberof CreateOrderRequest
     */
    'terminal'?: TerminalDetails;
    /**
     *
     * @type {OrderMeta}
     * @memberof CreateOrderRequest
     */
    'order_meta'?: OrderMeta;
    /**
     * Time after which the order expires. Customers will not be able to make the payment beyond the time specified here. We store timestamps in IST, but you can provide them in a valid ISO 8601 time format. Example 2021-07-02T10:20:12+05:30 for IST, 2021-07-02T10:20:12Z for UTC
     * @type {string}
     * @memberof CreateOrderRequest
     */
    'order_expiry_time'?: string;
    /**
     * Order note for reference.
     * @type {string}
     * @memberof CreateOrderRequest
     */
    'order_note'?: string;
    /**
     * Custom Tags in thr form of {\"key\":\"value\"} which can be passed for an order. A maximum of 10 tags can be added
     * @type {{ [key: string]: string; }}
     * @memberof CreateOrderRequest
     */
    'order_tags'?: {
        [key: string]: string;
    };
    /**
     * If you have Easy split enabled in your Cashfree account then you can use this option to split the order amount.
     * @type {Array<VendorSplit>}
     * @memberof CreateOrderRequest
     */
    'order_splits'?: Array<VendorSplit>;
}
/**
 * Request body to create a terminal
 * @export
 * @interface CreateTerminalRequest
 */
export interface CreateTerminalRequest {
    /**
     * merchant’s internal terminal id
     * @type {string}
     * @memberof CreateTerminalRequest
     */
    'terminal_id': string;
    /**
     * phone number assigned to the terminal
     * @type {string}
     * @memberof CreateTerminalRequest
     */
    'terminal_phone_no': string;
    /**
     * terminal name to be assigned by merchants
     * @type {string}
     * @memberof CreateTerminalRequest
     */
    'terminal_name': string;
    /**
     * address of the terminal. required for STOREFRONT
     * @type {string}
     * @memberof CreateTerminalRequest
     */
    'terminal_address'?: string;
    /**
     * terminal email ID of the AGENT/STOREFRONT assigned by merchants.
     * @type {string}
     * @memberof CreateTerminalRequest
     */
    'terminal_email': string;
    /**
     * additional note for terminal
     * @type {string}
     * @memberof CreateTerminalRequest
     */
    'terminal_note'?: string;
    /**
     * mention the terminal type. possible values - AGENT, STOREFRONT.
     * @type {string}
     * @memberof CreateTerminalRequest
     */
    'terminal_type': string;
    /**
     *
     * @type {CreateTerminalRequestTerminalMeta}
     * @memberof CreateTerminalRequest
     */
    'terminal_meta'?: CreateTerminalRequestTerminalMeta;
}
/**
 * terminal metadata. required field for storefront.
 * @export
 * @interface CreateTerminalRequestTerminalMeta
 */
export interface CreateTerminalRequestTerminalMeta {
    /**
     * name of the STOREFRONT operator.
     * @type {string}
     * @memberof CreateTerminalRequestTerminalMeta
     */
    'terminal_operator'?: string;
}
/**
 * Request body to create a terminal transaction
 * @export
 * @interface CreateTerminalTransactionRequest
 */
export interface CreateTerminalTransactionRequest {
    /**
     * cashfree order ID that was returned while creating an order.
     * @type {string}
     * @memberof CreateTerminalTransactionRequest
     */
    'cf_order_id': string;
    /**
     * cashfree terminal id. this is a required parameter when you do not provide the terminal phone number.
     * @type {string}
     * @memberof CreateTerminalTransactionRequest
     */
    'cf_terminal_id'?: string;
    /**
     * mention the payment method used for the transaction. possible values - QR_CODE, LINK.
     * @type {string}
     * @memberof CreateTerminalTransactionRequest
     */
    'payment_method': string;
    /**
     * agent mobile number assigned to the terminal. this is a required parameter when you do not provide the cf_terminal_id.
     * @type {string}
     * @memberof CreateTerminalTransactionRequest
     */
    'terminal_phone_no'?: string;
}
/**
 * Crytogram Card object
 * @export
 * @interface CryptogramEntity
 */
export interface CryptogramEntity {
    /**
     * instrument_id of saved instrument
     * @type {string}
     * @memberof CryptogramEntity
     */
    'instrument_id'?: string;
    /**
     * TRID issued by card networks
     * @type {string}
     * @memberof CryptogramEntity
     */
    'token_requestor_id'?: string;
    /**
     * token pan number
     * @type {string}
     * @memberof CryptogramEntity
     */
    'card_number'?: string;
    /**
     * token pan expiry month
     * @type {string}
     * @memberof CryptogramEntity
     */
    'card_expiry_mm'?: string;
    /**
     * token pan expiry year
     * @type {string}
     * @memberof CryptogramEntity
     */
    'card_expiry_yy'?: string;
    /**
     * cryptogram
     * @type {string}
     * @memberof CryptogramEntity
     */
    'cryptogram'?: string;
    /**
     * last 4 digits of original card number
     * @type {string}
     * @memberof CryptogramEntity
     */
    'card_display'?: string;
}
/**
 * The customer details that are necessary. Note that you can pass dummy details if your use case does not require the customer details.
 * @export
 * @interface CustomerDetails
 */
export interface CustomerDetails {
    /**
     * A unique identifier for the customer. Use alphanumeric values only.
     * @type {string}
     * @memberof CustomerDetails
     */
    'customer_id': string;
    /**
     * Customer email address.
     * @type {string}
     * @memberof CustomerDetails
     */
    'customer_email'?: string;
    /**
     * Customer phone number.
     * @type {string}
     * @memberof CustomerDetails
     */
    'customer_phone': string;
    /**
     * Name of the customer.
     * @type {string}
     * @memberof CustomerDetails
     */
    'customer_name'?: string;
    /**
     * Customer bank account. Required if you want to do a bank account check (TPV)
     * @type {string}
     * @memberof CustomerDetails
     */
    'customer_bank_account_number'?: string;
    /**
     * Customer bank IFSC. Required if you want to do a bank account check (TPV)
     * @type {string}
     * @memberof CustomerDetails
     */
    'customer_bank_ifsc'?: string;
    /**
     * Customer bank code. Required for net banking payments, if you want to do a bank account check (TPV)
     * @type {number}
     * @memberof CustomerDetails
     */
    'customer_bank_code'?: number;
    /**
     * Customer identifier at Cashfree. You will get this when you create/get customer
     * @type {string}
     * @memberof CustomerDetails
     */
    'customer_uid'?: string;
}
/**
 * Details of the customer for whom eligibility is being checked.
 * @export
 * @interface CustomerDetailsCardlessEMI
 */
export interface CustomerDetailsCardlessEMI {
    /**
     * Phone Number of the customer
     * @type {string}
     * @memberof CustomerDetailsCardlessEMI
     */
    'customer_phone': string;
}
/**
 * The complete customer entity
 * @export
 * @interface CustomerEntity
 */
export interface CustomerEntity {
    /**
     * unique id generated by cashfree for your customer
     * @type {string}
     * @memberof CustomerEntity
     */
    'customer_uid'?: string;
    /**
     * Customer Phone Number
     * @type {string}
     * @memberof CustomerEntity
     */
    'customer_phone'?: string;
    /**
     * Customer Email
     * @type {string}
     * @memberof CustomerEntity
     */
    'customer_email'?: string;
    /**
     * Customer Name
     * @type {string}
     * @memberof CustomerEntity
     */
    'customer_name'?: string;
}
/**
 * detils of the discount object of offer
 * @export
 * @interface DiscountDetails
 */
export interface DiscountDetails {
    /**
     * Type of discount
     * @type {string}
     * @memberof DiscountDetails
     */
    'discount_type': DiscountDetailsDiscountTypeEnum;
    /**
     * Value of Discount.
     * @type {number}
     * @memberof DiscountDetails
     */
    'discount_value': number;
    /**
     * Maximum Value of Discount allowed.
     * @type {number}
     * @memberof DiscountDetails
     */
    'max_discount_amount': number;
}
export declare const DiscountDetailsDiscountTypeEnum: {
    readonly FLAT: "flat";
    readonly PERCENTAGE: "percentage";
    readonly UNKNOWN_DEFAULT_OPEN_API: "11184809";
};
export type DiscountDetailsDiscountTypeEnum = typeof DiscountDetailsDiscountTypeEnum[keyof typeof DiscountDetailsDiscountTypeEnum];
/**
 *
 * @export
 * @interface EMIOffer
 */
export interface EMIOffer {
    /**
     * Type of emi offer. Possible values are `credit_card_emi`, `debit_card_emi`, `cardless_emi`
     * @type {string}
     * @memberof EMIOffer
     */
    'type': string;
    /**
     * Bank Name
     * @type {string}
     * @memberof EMIOffer
     */
    'issuer': string;
    /**
     *
     * @type {Array<number>}
     * @memberof EMIOffer
     */
    'tenures': Array<number>;
}
/**
 * Single EMI object
 * @export
 * @interface EMIPlansArray
 */
export interface EMIPlansArray {
    /**
     *
     * @type {number}
     * @memberof EMIPlansArray
     */
    'tenure'?: number;
    /**
     *
     * @type {number}
     * @memberof EMIPlansArray
     */
    'interest_rate'?: number;
    /**
     *
     * @type {string}
     * @memberof EMIPlansArray
     */
    'currency'?: string;
    /**
     *
     * @type {number}
     * @memberof EMIPlansArray
     */
    'emi'?: number;
    /**
     *
     * @type {number}
     * @memberof EMIPlansArray
     */
    'total_interest'?: number;
    /**
     *
     * @type {number}
     * @memberof EMIPlansArray
     */
    'total_amount'?: number;
}
/**
 * Carless EMI eligible entity
 * @export
 * @interface EligibilityCardlessEMIEntity
 */
export interface EligibilityCardlessEMIEntity {
    /**
     *
     * @type {boolean}
     * @memberof EligibilityCardlessEMIEntity
     */
    'eligibility'?: boolean;
    /**
     *
     * @type {string}
     * @memberof EligibilityCardlessEMIEntity
     */
    'entity_type'?: string;
    /**
     *
     * @type {string}
     * @memberof EligibilityCardlessEMIEntity
     */
    'entity_value'?: string;
    /**
     *
     * @type {CardlessEMIEntity}
     * @memberof EligibilityCardlessEMIEntity
     */
    'entity_details'?: CardlessEMIEntity;
}
/**
 * eligibilty request for cardless
 * @export
 * @interface EligibilityFetchCardlessEMIRequest
 */
export interface EligibilityFetchCardlessEMIRequest {
    /**
     *
     * @type {CardlessEMIQueries}
     * @memberof EligibilityFetchCardlessEMIRequest
     */
    'queries': CardlessEMIQueries;
}
/**
 * Eligiblty API request
 * @export
 * @interface EligibilityFetchOffersRequest
 */
export interface EligibilityFetchOffersRequest {
    /**
     *
     * @type {OfferQueries}
     * @memberof EligibilityFetchOffersRequest
     */
    'queries': OfferQueries;
    /**
     *
     * @type {OfferFilters}
     * @memberof EligibilityFetchOffersRequest
     */
    'filters'?: OfferFilters;
}
/**
 * Request to get eligible paylater payment methods
 * @export
 * @interface EligibilityFetchPaylaterRequest
 */
export interface EligibilityFetchPaylaterRequest {
    /**
     *
     * @type {CardlessEMIQueries}
     * @memberof EligibilityFetchPaylaterRequest
     */
    'queries': CardlessEMIQueries;
}
/**
 * eligibilty request to find eligible payment method
 * @export
 * @interface EligibilityFetchPaymentMethodsRequest
 */
export interface EligibilityFetchPaymentMethodsRequest {
    /**
     *
     * @type {PaymentMethodsQueries}
     * @memberof EligibilityFetchPaymentMethodsRequest
     */
    'queries': PaymentMethodsQueries;
    /**
     *
     * @type {PaymentMethodsFilters}
     * @memberof EligibilityFetchPaymentMethodsRequest
     */
    'filters'?: PaymentMethodsFilters;
}
/**
 * Eligible offer object
 * @export
 * @interface EligibilityOfferEntity
 */
export interface EligibilityOfferEntity {
    /**
     *
     * @type {boolean}
     * @memberof EligibilityOfferEntity
     */
    'eligibility'?: boolean;
    /**
     *
     * @type {string}
     * @memberof EligibilityOfferEntity
     */
    'entity_type'?: string;
    /**
     *
     * @type {string}
     * @memberof EligibilityOfferEntity
     */
    'entity_value'?: string;
    /**
     *
     * @type {OfferEntity}
     * @memberof EligibilityOfferEntity
     */
    'entity_details'?: OfferEntity;
}
/**
 * Eligible paylater payment method
 * @export
 * @interface EligibilityPaylaterEntity
 */
export interface EligibilityPaylaterEntity {
    /**
     *
     * @type {boolean}
     * @memberof EligibilityPaylaterEntity
     */
    'eligibility'?: boolean;
    /**
     *
     * @type {string}
     * @memberof EligibilityPaylaterEntity
     */
    'entity_type'?: string;
    /**
     *
     * @type {string}
     * @memberof EligibilityPaylaterEntity
     */
    'entity_value'?: string;
    /**
     *
     * @type {PaylaterEntity}
     * @memberof EligibilityPaylaterEntity
     */
    'entity_details'?: PaylaterEntity;
}
/**
 * Eligible payment methods details
 * @export
 * @interface EligibilityPaymentMethodsEntity
 */
export interface EligibilityPaymentMethodsEntity {
    /**
     *
     * @type {boolean}
     * @memberof EligibilityPaymentMethodsEntity
     */
    'eligibility'?: boolean;
    /**
     *
     * @type {string}
     * @memberof EligibilityPaymentMethodsEntity
     */
    'entity_type'?: string;
    /**
     *
     * @type {string}
     * @memberof EligibilityPaymentMethodsEntity
     */
    'entity_value'?: string;
    /**
     *
     * @type {EligibilityPaymentMethodsEntityEntityDetails}
     * @memberof EligibilityPaymentMethodsEntity
     */
    'entity_details'?: EligibilityPaymentMethodsEntityEntityDetails;
}
/**
 *
 * @export
 * @interface EligibilityPaymentMethodsEntityEntityDetails
 */
export interface EligibilityPaymentMethodsEntityEntityDetails {
    /**
     *
     * @type {Array<PaymentModeDetails>}
     * @memberof EligibilityPaymentMethodsEntityEntityDetails
     */
    'payment_method_details'?: Array<PaymentModeDetails>;
}
/**
 * The error details are present only for failed payments
 * @export
 * @interface ErrorDetailsInPaymentsEntity
 */
export interface ErrorDetailsInPaymentsEntity {
    /**
     *
     * @type {string}
     * @memberof ErrorDetailsInPaymentsEntity
     */
    'error_code'?: string;
    /**
     *
     * @type {string}
     * @memberof ErrorDetailsInPaymentsEntity
     */
    'error_description'?: string;
    /**
     *
     * @type {string}
     * @memberof ErrorDetailsInPaymentsEntity
     */
    'error_reason'?: string;
    /**
     *
     * @type {string}
     * @memberof ErrorDetailsInPaymentsEntity
     */
    'error_source'?: string;
    /**
     *
     * @type {string}
     * @memberof ErrorDetailsInPaymentsEntity
     */
    'error_code_raw'?: string;
    /**
     *
     * @type {string}
     * @memberof ErrorDetailsInPaymentsEntity
     */
    'error_description_raw'?: string;
    /**
     *
     * @type {string}
     * @memberof ErrorDetailsInPaymentsEntity
     */
    'error_subcode_raw'?: string;
}
/**
 * Recon object
 * @export
 * @interface FetchReconRequest
 */
export interface FetchReconRequest {
    /**
     *
     * @type {FetchReconRequestPagination}
     * @memberof FetchReconRequest
     */
    'pagination': FetchReconRequestPagination;
    /**
     *
     * @type {FetchReconRequestFilters}
     * @memberof FetchReconRequest
     */
    'filters': FetchReconRequestFilters;
}
/**
 *
 * @export
 * @interface FetchReconRequestFilters
 */
export interface FetchReconRequestFilters {
    /**
     * Specify the start date from when you want the settlement reconciliation details.
     * @type {string}
     * @memberof FetchReconRequestFilters
     */
    'start_date': string;
    /**
     * Specify the end date till when you want the settlement reconciliation details.
     * @type {string}
     * @memberof FetchReconRequestFilters
     */
    'end_date': string;
}
/**
 * To fetch the next set of settlements, pass the cursor received in the response to the next API call.   To receive the data for the first time, pass the cursor as null.   Limit would be number of settlements that you want to receive.
 * @export
 * @interface FetchReconRequestPagination
 */
export interface FetchReconRequestPagination {
    /**
     * Number of settlements you want to fetch in the next iteration. Maximum limit is 1000, default value is 10.
     * @type {number}
     * @memberof FetchReconRequestPagination
     */
    'limit': number;
    /**
     * Specifies from where the next set of settlement details should be fetched.
     * @type {string}
     * @memberof FetchReconRequestPagination
     */
    'cursor'?: string;
}
/**
 * Request to fetch settlement
 * @export
 * @interface FetchSettlementsRequest
 */
export interface FetchSettlementsRequest {
    /**
     *
     * @type {FetchSettlementsRequestPagination}
     * @memberof FetchSettlementsRequest
     */
    'pagination': FetchSettlementsRequestPagination;
    /**
     *
     * @type {FetchSettlementsRequestFilters}
     * @memberof FetchSettlementsRequest
     */
    'filters': FetchSettlementsRequestFilters;
}
/**
 * Specify either the Settlement ID, Settlement UTR, or start date and end date to fetch the settlement details.
 * @export
 * @interface FetchSettlementsRequestFilters
 */
export interface FetchSettlementsRequestFilters {
    /**
     * List of settlement IDs for which you want the settlement reconciliation details.
     * @type {Array<string>}
     * @memberof FetchSettlementsRequestFilters
     */
    'cf_settlement_ids'?: Array<string>;
    /**
     * List of settlement UTRs for which you want the settlement reconciliation details.
     * @type {Array<string>}
     * @memberof FetchSettlementsRequestFilters
     */
    'settlement_utrs'?: Array<string>;
    /**
     * Specify the start date from when you want the settlement reconciliation details.
     * @type {string}
     * @memberof FetchSettlementsRequestFilters
     */
    'start_date'?: string;
    /**
     * Specify the end date till when you want the settlement reconciliation details.
     * @type {string}
     * @memberof FetchSettlementsRequestFilters
     */
    'end_date'?: string;
}
/**
 * To fetch the next set of settlements, pass the cursor received in the response to the next API call.   To receive the data for the first time, pass the cursor as null.   Limit would be number of settlements that you want to receive.
 * @export
 * @interface FetchSettlementsRequestPagination
 */
export interface FetchSettlementsRequestPagination {
    /**
     * The number of settlements you want to fetch. Maximum limit is 1000, default value is 10.
     * @type {number}
     * @memberof FetchSettlementsRequestPagination
     */
    'limit': number;
    /**
     * Specifies from where the next set of settlement details should be fetched.
     * @type {string}
     * @memberof FetchSettlementsRequestPagination
     */
    'cursor'?: string;
}
/**
 * Fetch Static QR Codes using terminal ID or phone number
 * @export
 * @interface FetchTerminalQRCodesEntity
 */
export interface FetchTerminalQRCodesEntity {
    /**
     * Name of the bank that is linked to the Static QR.
     * @type {string}
     * @memberof FetchTerminalQRCodesEntity
     */
    'bank'?: string;
    /**
     * Base-64 Encoded QR Code URL
     * @type {string}
     * @memberof FetchTerminalQRCodesEntity
     */
    'qrCode'?: string;
    /**
     * URL of the qr Code.
     * @type {string}
     * @memberof FetchTerminalQRCodesEntity
     */
    'qrCodeUrl'?: string;
    /**
     * Status of the static QR.
     * @type {string}
     * @memberof FetchTerminalQRCodesEntity
     */
    'status'?: string;
}
/**
 * Error when idempotency fails. Different request body with the same idempotent key
 * @export
 * @interface IdempotencyError
 */
export interface IdempotencyError {
    /**
     *
     * @type {string}
     * @memberof IdempotencyError
     */
    'message'?: string;
    /**
     *
     * @type {string}
     * @memberof IdempotencyError
     */
    'code'?: string;
    /**
     * idempotency_error
     * @type {string}
     * @memberof IdempotencyError
     */
    'type'?: IdempotencyErrorTypeEnum;
}
export declare const IdempotencyErrorTypeEnum: {
    readonly IDEMPOTENCY_ERROR: "idempotency_error";
    readonly UNKNOWN_DEFAULT_OPEN_API: "11184809";
};
export type IdempotencyErrorTypeEnum = typeof IdempotencyErrorTypeEnum[keyof typeof IdempotencyErrorTypeEnum];
/**
 * Saved card instrument object
 * @export
 * @interface InstrumentEntity
 */
export interface InstrumentEntity {
    /**
     * customer_id for which the instrument was saved
     * @type {string}
     * @memberof InstrumentEntity
     */
    'customer_id'?: string;
    /**
     * cf_payment_id of the successful transaction done while saving instrument
     * @type {string}
     * @memberof InstrumentEntity
     */
    'afa_reference'?: string;
    /**
     * saved instrument id
     * @type {string}
     * @memberof InstrumentEntity
     */
    'instrument_id'?: string;
    /**
     * Type of the saved instrument
     * @type {string}
     * @memberof InstrumentEntity
     */
    'instrument_type'?: InstrumentEntityInstrumentTypeEnum;
    /**
     * Unique id for the saved instrument
     * @type {string}
     * @memberof InstrumentEntity
     */
    'instrument_uid'?: string;
    /**
     * masked card number displayed to the customer
     * @type {string}
     * @memberof InstrumentEntity
     */
    'instrument_display'?: string;
    /**
     * Status of the saved instrument.
     * @type {string}
     * @memberof InstrumentEntity
     */
    'instrument_status'?: InstrumentEntityInstrumentStatusEnum;
    /**
     * Timestamp at which instrument was saved.
     * @type {string}
     * @memberof InstrumentEntity
     */
    'created_at'?: string;
    /**
     *
     * @type {SavedInstrumentMeta}
     * @memberof InstrumentEntity
     */
    'instrument_meta'?: SavedInstrumentMeta;
}
export declare const InstrumentEntityInstrumentTypeEnum: {
    readonly CARD: "card";
    readonly UNKNOWN_DEFAULT_OPEN_API: "11184809";
};
export type InstrumentEntityInstrumentTypeEnum = typeof InstrumentEntityInstrumentTypeEnum[keyof typeof InstrumentEntityInstrumentTypeEnum];
export declare const InstrumentEntityInstrumentStatusEnum: {
    readonly ACTIVE: "ACTIVE";
    readonly INACTIVE: "INACTIVE";
    readonly UNKNOWN_DEFAULT_OPEN_API: "11184809";
};
export type InstrumentEntityInstrumentStatusEnum = typeof InstrumentEntityInstrumentStatusEnum[keyof typeof InstrumentEntityInstrumentStatusEnum];
/**
 * Instrument webhook object
 * @export
 * @interface InstrumentWebhook
 */
export interface InstrumentWebhook {
    /**
     *
     * @type {InstrumentWebhookData}
     * @memberof InstrumentWebhook
     */
    'data'?: InstrumentWebhookData;
}
/**
 *
 * @export
 * @interface InstrumentWebhookData
 */
export interface InstrumentWebhookData {
    /**
     *
     * @type {InstrumentWebhookDataEntity}
     * @memberof InstrumentWebhookData
     */
    'data'?: InstrumentWebhookDataEntity;
    /**
     *
     * @type {string}
     * @memberof InstrumentWebhookData
     */
    'event_time'?: string;
    /**
     *
     * @type {string}
     * @memberof InstrumentWebhookData
     */
    'type'?: string;
}
/**
 * data entity in webhook
 * @export
 * @interface InstrumentWebhookDataEntity
 */
export interface InstrumentWebhookDataEntity {
    /**
     *
     * @type {InstrumentEntity}
     * @memberof InstrumentWebhookDataEntity
     */
    'instrument'?: InstrumentEntity;
}
/**
 * Payment link customer entity
 * @export
 * @interface LinkCustomerDetailsEntity
 */
export interface LinkCustomerDetailsEntity {
    /**
     * Customer phone number
     * @type {string}
     * @memberof LinkCustomerDetailsEntity
     */
    'customer_phone': string;
    /**
     * Customer email address
     * @type {string}
     * @memberof LinkCustomerDetailsEntity
     */
    'customer_email'?: string;
    /**
     * Customer name
     * @type {string}
     * @memberof LinkCustomerDetailsEntity
     */
    'customer_name'?: string;
}
/**
 * Payment link success creation response object
 * @export
 * @interface LinkEntity
 */
export interface LinkEntity {
    /**
     *
     * @type {string}
     * @memberof LinkEntity
     */
    'cf_link_id'?: string;
    /**
     *
     * @type {string}
     * @memberof LinkEntity
     */
    'link_id'?: string;
    /**
     *
     * @type {string}
     * @memberof LinkEntity
     */
    'link_status'?: string;
    /**
     *
     * @type {string}
     * @memberof LinkEntity
     */
    'link_currency'?: string;
    /**
     *
     * @type {number}
     * @memberof LinkEntity
     */
    'link_amount'?: number;
    /**
     *
     * @type {number}
     * @memberof LinkEntity
     */
    'link_amount_paid'?: number;
    /**
     *
     * @type {boolean}
     * @memberof LinkEntity
     */
    'link_partial_payments'?: boolean;
    /**
     *
     * @type {number}
     * @memberof LinkEntity
     */
    'link_minimum_partial_amount'?: number;
    /**
     *
     * @type {string}
     * @memberof LinkEntity
     */
    'link_purpose'?: string;
    /**
     *
     * @type {string}
     * @memberof LinkEntity
     */
    'link_created_at'?: string;
    /**
     *
     * @type {LinkCustomerDetailsEntity}
     * @memberof LinkEntity
     */
    'customer_details'?: LinkCustomerDetailsEntity;
    /**
     *
     * @type {LinkMetaResponseEntity}
     * @memberof LinkEntity
     */
    'link_meta'?: LinkMetaResponseEntity;
    /**
     *
     * @type {string}
     * @memberof LinkEntity
     */
    'link_url'?: string;
    /**
     *
     * @type {string}
     * @memberof LinkEntity
     */
    'link_expiry_time'?: string;
    /**
     * Key-value pair that can be used to store additional information about the entity. Maximum 5 key-value pairs
     * @type {{ [key: string]: string; }}
     * @memberof LinkEntity
     */
    'link_notes'?: {
        [key: string]: string;
    };
    /**
     *
     * @type {boolean}
     * @memberof LinkEntity
     */
    'link_auto_reminders'?: boolean;
    /**
     *
     * @type {LinkNotifyEntity}
     * @memberof LinkEntity
     */
    'link_notify'?: LinkNotifyEntity;
}
/**
 * Payment link meta information object
 * @export
 * @interface LinkMetaResponseEntity
 */
export interface LinkMetaResponseEntity {
    /**
     * Notification URL for server-server communication. It should be an https URL.
     * @type {string}
     * @memberof LinkMetaResponseEntity
     */
    'notify_url'?: string;
    /**
     * If \"true\", link will directly open UPI Intent flow on mobile, and normal link flow elsewhere
     * @type {boolean}
     * @memberof LinkMetaResponseEntity
     */
    'upi_intent'?: boolean;
    /**
     * The URL to which user will be redirected to after the payment is done on the link. Maximum length: 250.
     * @type {string}
     * @memberof LinkMetaResponseEntity
     */
    'return_url'?: string;
    /**
     * Allowed payment modes for this link. Pass comma-separated values among following options - \"cc\", \"dc\", \"ccc\", \"ppc\", \"nb\", \"upi\", \"paypal\", \"app\". Leave it blank to show all available payment methods
     * @type {string}
     * @memberof LinkMetaResponseEntity
     */
    'payment_methods'?: string;
}
/**
 * Payment link Notify Object for SMS and Email
 * @export
 * @interface LinkNotifyEntity
 */
export interface LinkNotifyEntity {
    /**
     * If \"true\", Cashfree will send sms on customer_phone
     * @type {boolean}
     * @memberof LinkNotifyEntity
     */
    'send_sms'?: boolean;
    /**
     * If \"true\", Cashfree will send email on customer_email
     * @type {boolean}
     * @memberof LinkNotifyEntity
     */
    'send_email'?: boolean;
}
/**
 * Payment method for netbanking object
 * @export
 * @interface NetBankingPaymentMethod
 */
export interface NetBankingPaymentMethod {
    /**
     *
     * @type {Netbanking}
     * @memberof NetBankingPaymentMethod
     */
    'netbanking': Netbanking;
}
/**
 * Netbanking payment method request body
 * @export
 * @interface Netbanking
 */
export interface Netbanking {
    /**
     * The channel for netbanking will always be `link`
     * @type {string}
     * @memberof Netbanking
     */
    'channel': string;
    /**
     * Bank code
     * @type {number}
     * @memberof Netbanking
     */
    'netbanking_bank_code'?: number;
    /**
     * String code for bank
     * @type {string}
     * @memberof Netbanking
     */
    'netbanking_bank_name'?: string;
}
/**
 * returns all offers
 * @export
 * @interface OfferAll
 */
export interface OfferAll {
    /**
     * All offers applicable
     * @type {object}
     * @memberof OfferAll
     */
    'all': object;
}
/**
 * Offers related to cards
 * @export
 * @interface OfferCard
 */
export interface OfferCard {
    /**
     *
     * @type {CardOffer}
     * @memberof OfferCard
     */
    'card': CardOffer;
}
/**
 * Offer details and type
 * @export
 * @interface OfferDetails
 */
export interface OfferDetails {
    /**
     * Offer Type for the Offer.
     * @type {string}
     * @memberof OfferDetails
     */
    'offer_type': OfferDetailsOfferTypeEnum;
    /**
     *
     * @type {DiscountDetails}
     * @memberof OfferDetails
     */
    'discount_details'?: DiscountDetails;
    /**
     *
     * @type {CashbackDetails}
     * @memberof OfferDetails
     */
    'cashback_details'?: CashbackDetails;
}
export declare const OfferDetailsOfferTypeEnum: {
    readonly DISCOUNT: "DISCOUNT";
    readonly CASHBACK: "CASHBACK";
    readonly DISCOUNT_AND_CASHBACK: "DISCOUNT_AND_CASHBACK";
    readonly NO_COST_EMI: "NO_COST_EMI";
    readonly UNKNOWN_DEFAULT_OPEN_API: "11184809";
};
export type OfferDetailsOfferTypeEnum = typeof OfferDetailsOfferTypeEnum[keyof typeof OfferDetailsOfferTypeEnum];
/**
 * EMI offer object
 * @export
 * @interface OfferEMI
 */
export interface OfferEMI {
    /**
     *
     * @type {EMIOffer}
     * @memberof OfferEMI
     */
    'emi': EMIOffer;
}
/**
 * Offer entity object
 * @export
 * @interface OfferEntity
 */
export interface OfferEntity {
    /**
     *
     * @type {string}
     * @memberof OfferEntity
     */
    'offer_id'?: string;
    /**
     *
     * @type {string}
     * @memberof OfferEntity
     */
    'offer_status'?: string;
    /**
     *
     * @type {OfferMeta}
     * @memberof OfferEntity
     */
    'offer_meta'?: OfferMeta;
    /**
     *
     * @type {OfferTnc}
     * @memberof OfferEntity
     */
    'offer_tnc'?: OfferTnc;
    /**
     *
     * @type {OfferDetails}
     * @memberof OfferEntity
     */
    'offer_details'?: OfferDetails;
    /**
     *
     * @type {OfferValidations}
     * @memberof OfferEntity
     */
    'offer_validations'?: OfferValidations;
}
/**
 * Filter for offers
 * @export
 * @interface OfferFilters
 */
export interface OfferFilters {
    /**
     * Array of offer_type to be filtered.
     * @type {Array<OfferType>}
     * @memberof OfferFilters
     */
    'offer_type'?: Array<OfferType>;
}
/**
 * Offer meta details object
 * @export
 * @interface OfferMeta
 */
export interface OfferMeta {
    /**
     * Title for the Offer.
     * @type {string}
     * @memberof OfferMeta
     */
    'offer_title': string;
    /**
     * Description for the Offer.
     * @type {string}
     * @memberof OfferMeta
     */
    'offer_description': string;
    /**
     * Unique identifier for the Offer.
     * @type {string}
     * @memberof OfferMeta
     */
    'offer_code': string;
    /**
     * Start Time for the Offer
     * @type {string}
     * @memberof OfferMeta
     */
    'offer_start_time': string;
    /**
     * Expiry Time for the Offer
     * @type {string}
     * @memberof OfferMeta
     */
    'offer_end_time': string;
}
/**
 * Offer object ofr NetBanking
 * @export
 * @interface OfferNB
 */
export interface OfferNB {
    /**
     *
     * @type {OfferNBNetbanking}
     * @memberof OfferNB
     */
    'netbanking': OfferNBNetbanking;
}
/**
 *
 * @export
 * @interface OfferNBNetbanking
 */
export interface OfferNBNetbanking {
    /**
     *
     * @type {string}
     * @memberof OfferNBNetbanking
     */
    'bank_name'?: string;
}
/**
 * Offer object for paylater
 * @export
 * @interface OfferPaylater
 */
export interface OfferPaylater {
    /**
     *
     * @type {PaylaterOffer}
     * @memberof OfferPaylater
     */
    'paylater': PaylaterOffer;
}
/**
 * Offer Query Object
 * @export
 * @interface OfferQueries
 */
export interface OfferQueries {
    /**
     * OrderId of the order. Either of `order_id` or `order_amount` is mandatory.
     * @type {string}
     * @memberof OfferQueries
     */
    'order_id'?: string;
    /**
     * Amount of the order. OrderId of the order. Either of `order_id` or `order_amount` is mandatory.
     * @type {number}
     * @memberof OfferQueries
     */
    'amount'?: number;
}
/**
 * Offer terms and condition object
 * @export
 * @interface OfferTnc
 */
export interface OfferTnc {
    /**
     * TnC Type for the Offer. It can be either `text` or `link`
     * @type {string}
     * @memberof OfferTnc
     */
    'offer_tnc_type': OfferTncOfferTncTypeEnum;
    /**
     * TnC for the Offer.
     * @type {string}
     * @memberof OfferTnc
     */
    'offer_tnc_value': string;
}
export declare const OfferTncOfferTncTypeEnum: {
    readonly TEXT: "text";
    readonly LINK: "link";
    readonly UNKNOWN_DEFAULT_OPEN_API: "11184809";
};
export type OfferTncOfferTncTypeEnum = typeof OfferTncOfferTncTypeEnum[keyof typeof OfferTncOfferTncTypeEnum];
/**
 * Offer Type Object
 * @export
 * @enum {string}
 */
export declare const OfferType: {
    readonly DISCOUNT: "DISCOUNT";
    readonly CASHBACK: "CASHBACK";
    readonly DISCOUNT_AND_CASHBACK: "DISCOUNT_AND_CASHBACK";
    readonly NO_COST_EMI: "NO_COST_EMI";
    readonly UNKNOWN_DEFAULT_OPEN_API: "11184809";
};
export type OfferType = typeof OfferType[keyof typeof OfferType];
/**
 * Offer object for UPI
 * @export
 * @interface OfferUPI
 */
export interface OfferUPI {
    /**
     *
     * @type {object}
     * @memberof OfferUPI
     */
    'upi': object;
}
/**
 * Offer validation object
 * @export
 * @interface OfferValidations
 */
export interface OfferValidations {
    /**
     * Minimum Amount for Offer to be Applicable
     * @type {number}
     * @memberof OfferValidations
     */
    'min_amount'?: number;
    /**
     *
     * @type {OfferValidationsPaymentMethod}
     * @memberof OfferValidations
     */
    'payment_method': OfferValidationsPaymentMethod;
}
/**
 * @type OfferValidationsPaymentMethod
 * @export
 */
export type OfferValidationsPaymentMethod = OfferAll | OfferCard | OfferEMI | OfferNB | OfferPaylater | OfferUPI | OfferWallet;
/**
 * Offer object for wallet payment method
 * @export
 * @interface OfferWallet
 */
export interface OfferWallet {
    /**
     *
     * @type {WalletOffer}
     * @memberof OfferWallet
     */
    'app': WalletOffer;
}
/**
 * This is the response shared when merchant inovkes the OTP submit or resend API
 * @export
 * @interface OrderAuthenticateEntity
 */
export interface OrderAuthenticateEntity {
    /**
     * The payment id for which this request was sent
     * @type {string}
     * @memberof OrderAuthenticateEntity
     */
    'cf_payment_id'?: string;
    /**
     * The action that was invoked for this request.
     * @type {string}
     * @memberof OrderAuthenticateEntity
     */
    'action'?: OrderAuthenticateEntityActionEnum;
    /**
     * Status of the is action. Will be either failed or successful. If the action is successful, you should still call the authorization status to verify the final payment status.
     * @type {string}
     * @memberof OrderAuthenticateEntity
     */
    'authenticate_status'?: OrderAuthenticateEntityAuthenticateStatusEnum;
    /**
     * Human readable message which describes the status in more detail
     * @type {string}
     * @memberof OrderAuthenticateEntity
     */
    'payment_message'?: string;
}
export declare const OrderAuthenticateEntityActionEnum: {
    readonly SUBMIT_OTP: "SUBMIT_OTP";
    readonly RESEND_OTP: "RESEND_OTP";
    readonly UNKNOWN_DEFAULT_OPEN_API: "11184809";
};
export type OrderAuthenticateEntityActionEnum = typeof OrderAuthenticateEntityActionEnum[keyof typeof OrderAuthenticateEntityActionEnum];
export declare const OrderAuthenticateEntityAuthenticateStatusEnum: {
    readonly FAILED: "FAILED";
    readonly SUCCESS: "SUCCESS";
    readonly UNKNOWN_DEFAULT_OPEN_API: "11184809";
};
export type OrderAuthenticateEntityAuthenticateStatusEnum = typeof OrderAuthenticateEntityAuthenticateStatusEnum[keyof typeof OrderAuthenticateEntityAuthenticateStatusEnum];
/**
 * OTP to be submitted for headless/native OTP
 * @export
 * @interface OrderAuthenticatePaymentRequest
 */
export interface OrderAuthenticatePaymentRequest {
    /**
     * OTP to be submitted
     * @type {string}
     * @memberof OrderAuthenticatePaymentRequest
     */
    'otp': string;
    /**
     * The action for this workflow. Could be either SUBMIT_OTP or RESEND_OTP
     * @type {string}
     * @memberof OrderAuthenticatePaymentRequest
     */
    'action': OrderAuthenticatePaymentRequestActionEnum;
}
export declare const OrderAuthenticatePaymentRequestActionEnum: {
    readonly SUBMIT_OTP: "SUBMIT_OTP";
    readonly RESEND_OTP: "RESEND_OTP";
    readonly UNKNOWN_DEFAULT_OPEN_API: "11184809";
};
export type OrderAuthenticatePaymentRequestActionEnum = typeof OrderAuthenticatePaymentRequestActionEnum[keyof typeof OrderAuthenticatePaymentRequestActionEnum];
/**
 * create refund request object
 * @export
 * @interface OrderCreateRefundRequest
 */
export interface OrderCreateRefundRequest {
    /**
     * Amount to be refunded. Should be lesser than or equal to the transaction amount. (Decimals allowed)
     * @type {number}
     * @memberof OrderCreateRefundRequest
     */
    'refund_amount': number;
    /**
     * An unique ID to associate the refund with. Provie alphanumeric values
     * @type {string}
     * @memberof OrderCreateRefundRequest
     */
    'refund_id': string;
    /**
     * A refund note for your reference.
     * @type {string}
     * @memberof OrderCreateRefundRequest
     */
    'refund_note'?: string;
    /**
     * Speed at which the refund is processed. It\'s an optional field with default being STANDARD
     * @type {string}
     * @memberof OrderCreateRefundRequest
     */
    'refund_speed'?: OrderCreateRefundRequestRefundSpeedEnum;
    /**
     *
     * @type {Array<VendorSplit>}
     * @memberof OrderCreateRefundRequest
     */
    'refund_splits'?: Array<VendorSplit>;
}
export declare const OrderCreateRefundRequestRefundSpeedEnum: {
    readonly STANDARD: "STANDARD";
    readonly INSTANT: "INSTANT";
    readonly UNKNOWN_DEFAULT_OPEN_API: "11184809";
};
export type OrderCreateRefundRequestRefundSpeedEnum = typeof OrderCreateRefundRequestRefundSpeedEnum[keyof typeof OrderCreateRefundRequestRefundSpeedEnum];
/**
 * The complete order entity
 * @export
 * @interface OrderEntity
 */
export interface OrderEntity {
    /**
     * unique id generated by cashfree for your order
     * @type {string}
     * @memberof OrderEntity
     */
    'cf_order_id'?: string;
    /**
     * order_id sent during the api request
     * @type {string}
     * @memberof OrderEntity
     */
    'order_id'?: string;
    /**
     * Type of the entity.
     * @type {string}
     * @memberof OrderEntity
     */
    'entity'?: string;
    /**
     * Currency of the order. Example INR
     * @type {string}
     * @memberof OrderEntity
     */
    'order_currency'?: string;
    /**
     *
     * @type {number}
     * @memberof OrderEntity
     */
    'order_amount'?: number;
    /**
     * Possible values are  - `ACTIVE`: Order does not have a sucessful transaction yet - `PAID`: Order is PAID with one successful transaction - `EXPIRED`: Order was not PAID and not it has expired. No transaction can be initiated for an EXPIRED order. `TERMINATED`: Order terminated `TERMINATION_REQUESTED`: Order termination requested
     * @type {string}
     * @memberof OrderEntity
     */
    'order_status'?: string;
    /**
     *
     * @type {string}
     * @memberof OrderEntity
     */
    'payment_session_id'?: string;
    /**
     *
     * @type {string}
     * @memberof OrderEntity
     */
    'order_expiry_time'?: string;
    /**
     * Additional note for order
     * @type {string}
     * @memberof OrderEntity
     */
    'order_note'?: string;
    /**
     * When the order was created at cashfree\'s server
     * @type {string}
     * @memberof OrderEntity
     */
    'created_at'?: string;
    /**
     *
     * @type {Array<VendorSplit>}
     * @memberof OrderEntity
     */
    'order_splits'?: Array<VendorSplit>;
    /**
     *
     * @type {CustomerDetails}
     * @memberof OrderEntity
     */
    'customer_details'?: CustomerDetails;
    /**
     *
     * @type {OrderMeta}
     * @memberof OrderEntity
     */
    'order_meta'?: OrderMeta;
    /**
     * Custom Tags in thr form of {\"key\":\"value\"} which can be passed for an order. A maximum of 10 tags can be added
     * @type {{ [key: string]: string; }}
     * @memberof OrderEntity
     */
    'order_tags'?: {
        [key: string]: string;
    };
}
/**
 * Optional meta details to control how the customer pays and how payment journey completes
 * @export
 * @interface OrderMeta
 */
export interface OrderMeta {
    /**
     * The URL to which user will be redirected to after the payment on bank OTP page. Maximum length: 250. We suggest to keep context of order_id in your return_url so that you can identify the order when customer lands on your page. Example of return_url format could be https://example.com/return?order_id=myOrderId
     * @type {string}
     * @memberof OrderMeta
     */
    'return_url'?: string;
    /**
     * Notification URL for server-server communication. Useful when user\'s connection drops while re-directing. NotifyUrl should be an https URL. Maximum length: 250.
     * @type {string}
     * @memberof OrderMeta
     */
    'notify_url'?: string;
    /**
     * Allowed payment modes for this order. Pass comma-separated values among following options - \"cc\", \"dc\", \"ccc\", \"ppc\",\"nb\",\"upi\",\"paypal\",\"app\",\"paylater\",\"cardlessemi\",\"dcemi\",\"ccemi\",\"banktransfer\". Leave it blank to show all available payment methods
     * @type {any}
     * @memberof OrderMeta
     */
    'payment_methods'?: any;
}
/**
 * the data object pay api
 * @export
 * @interface OrderPayData
 */
export interface OrderPayData {
    /**
     *
     * @type {string}
     * @memberof OrderPayData
     */
    'url'?: string;
    /**
     *
     * @type {object}
     * @memberof OrderPayData
     */
    'payload'?: object;
    /**
     *
     * @type {string}
     * @memberof OrderPayData
     */
    'content_type'?: string;
    /**
     *
     * @type {string}
     * @memberof OrderPayData
     */
    'method'?: string;
}
/**
 * Order Pay response once you create a transaction for that order
 * @export
 * @interface PayOrderEntity
 */
export interface PayOrderEntity {
    /**
     * total amount payable
     * @type {number}
     * @memberof PayOrderEntity
     */
    'payment_amount'?: number;
    /**
     * Payment identifier created by Cashfree
     * @type {string}
     * @memberof PayOrderEntity
     */
    'cf_payment_id'?: string;
    /**
     * One of [\"upi\", \"netbanking\", \"card\", \"app\", \"cardless_emi\", \"paylater\", \"banktransfer\"]
     * @type {string}
     * @memberof PayOrderEntity
     */
    'payment_method'?: PayOrderEntityPaymentMethodEnum;
    /**
     * One of [\"link\", \"collect\", \"qrcode\"]. In an older version we used to support different channels like \'gpay\', \'phonepe\' etc. However, we now support only the following channels - link, collect and qrcode. To process payments using gpay, you will have to provide channel as \'link\' and provider as \'gpay\'
     * @type {string}
     * @memberof PayOrderEntity
     */
    'channel'?: PayOrderEntityChannelEnum;
    /**
     * One of [\"link\", \"custom\", \"form\"]
     * @type {string}
     * @memberof PayOrderEntity
     */
    'action'?: PayOrderEntityActionEnum;
    /**
     *
     * @type {OrderPayData}
     * @memberof PayOrderEntity
     */
    'data'?: OrderPayData;
}
export declare const PayOrderEntityPaymentMethodEnum: {
    readonly NETBANKING: "netbanking";
    readonly CARD: "card";
    readonly UPI: "upi";
    readonly APP: "app";
    readonly CARDLESS_EMI: "cardless_emi";
    readonly PAYLATER: "paylater";
    readonly BANKTRANSFER: "banktransfer";
    readonly UNKNOWN_DEFAULT_OPEN_API: "11184809";
};
export type PayOrderEntityPaymentMethodEnum = typeof PayOrderEntityPaymentMethodEnum[keyof typeof PayOrderEntityPaymentMethodEnum];
export declare const PayOrderEntityChannelEnum: {
    readonly LINK: "link";
    readonly COLLECT: "collect";
    readonly QRCODE: "qrcode";
    readonly POST: "post";
    readonly UNKNOWN_DEFAULT_OPEN_API: "11184809";
};
export type PayOrderEntityChannelEnum = typeof PayOrderEntityChannelEnum[keyof typeof PayOrderEntityChannelEnum];
export declare const PayOrderEntityActionEnum: {
    readonly LINK: "link";
    readonly CUSTOM: "custom";
    readonly FORM: "form";
    readonly POST: "post";
    readonly UNKNOWN_DEFAULT_OPEN_API: "11184809";
};
export type PayOrderEntityActionEnum = typeof PayOrderEntityActionEnum[keyof typeof PayOrderEntityActionEnum];
/**
 * Complete object for the pay api that uses payment method objects
 * @export
 * @interface PayOrderRequest
 */
export interface PayOrderRequest {
    /**
     *
     * @type {string}
     * @memberof PayOrderRequest
     */
    'payment_session_id': string;
    /**
     *
     * @type {PayOrderRequestPaymentMethod}
     * @memberof PayOrderRequest
     */
    'payment_method': PayOrderRequestPaymentMethod;
    /**
     *
     * @type {boolean}
     * @memberof PayOrderRequest
     */
    'save_instrument'?: boolean;
    /**
     * This is required if any offers needs to be applied to the order.
     * @type {string}
     * @memberof PayOrderRequest
     */
    'offer_id'?: string;
}
/**
 * @type PayOrderRequestPaymentMethod
 * @export
 */
export type PayOrderRequestPaymentMethod = AppPaymentMethod | CardEMIPaymentMethod | CardPaymentMethod | CardlessEMIPaymentMethod | NetBankingPaymentMethod | PaylaterPaymentMethod | UPIPaymentMethod;
/**
 * Paylater payment method
 * @export
 * @interface Paylater
 */
export interface Paylater {
    /**
     * The channel for cardless EMI is always `link`
     * @type {string}
     * @memberof Paylater
     */
    'channel'?: string;
    /**
     * One of [\"kotak\", \"flexipay\", \"zestmoney\", \"lazypay\", \"olapostpaid\",\"simpl\", \"freechargepaylater\"]. Please note that Flexipay is offered by HDFC bank
     * @type {string}
     * @memberof Paylater
     */
    'provider'?: PaylaterProviderEnum;
    /**
     * Customers phone number for this payment instrument. If the customer is not eligible you will receive a 400 error with type as \'invalid_request_error\' and code as \'invalid_request_error\'
     * @type {string}
     * @memberof Paylater
     */
    'phone'?: string;
}
export declare const PaylaterProviderEnum: {
    readonly KOTAK: "kotak";
    readonly FLEXIPAY: "flexipay";
    readonly ZESTMONEY: "zestmoney";
    readonly LAZYPAY: "lazypay";
    readonly OLAPOSTPAID: "olapostpaid";
    readonly SIMPL: "simpl";
    readonly FREECHARGEPAYLATER: "freechargepaylater";
    readonly UNKNOWN_DEFAULT_OPEN_API: "11184809";
};
export type PaylaterProviderEnum = typeof PaylaterProviderEnum[keyof typeof PaylaterProviderEnum];
/**
 * Paylater Entity
 * @export
 * @interface PaylaterEntity
 */
export interface PaylaterEntity {
    /**
     *
     * @type {string}
     * @memberof PaylaterEntity
     */
    'payment_method'?: string;
}
/**
 *
 * @export
 * @interface PaylaterOffer
 */
export interface PaylaterOffer {
    /**
     *
     * @type {string}
     * @memberof PaylaterOffer
     */
    'provider'?: string;
}
/**
 * paylater payment method
 * @export
 * @interface PaylaterPaymentMethod
 */
export interface PaylaterPaymentMethod {
    /**
     *
     * @type {Paylater}
     * @memberof PaylaterPaymentMethod
     */
    'paylater': Paylater;
}
/**
 * payment entity full object
 * @export
 * @interface PaymentEntity
 */
export interface PaymentEntity {
    /**
     *
     * @type {string}
     * @memberof PaymentEntity
     */
    'cf_payment_id'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentEntity
     */
    'order_id'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentEntity
     */
    'entity'?: string;
    /**
     *
     * @type {ErrorDetailsInPaymentsEntity}
     * @memberof PaymentEntity
     */
    'error_details'?: ErrorDetailsInPaymentsEntity;
    /**
     *
     * @type {boolean}
     * @memberof PaymentEntity
     */
    'is_captured'?: boolean;
    /**
     * Order amount can be different from payment amount if you collect service fee from the customer
     * @type {number}
     * @memberof PaymentEntity
     */
    'order_amount'?: number;
    /**
     * Type of payment group. One of [\'prepaid_card\', \'upi_ppi_offline\', \'cash\', \'upi_credit_card\', \'paypal\', \'net_banking\', \'cardless_emi\', \'credit_card\', \'bank_transfer\', \'pay_later\', \'debit_card_emi\', \'debit_card\', \'wallet\', \'upi_ppi\', \'upi\', \'credit_card_emi\']
     * @type {string}
     * @memberof PaymentEntity
     */
    'payment_group'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentEntity
     */
    'payment_currency'?: string;
    /**
     *
     * @type {number}
     * @memberof PaymentEntity
     */
    'payment_amount'?: number;
    /**
     * This is the time when the payment was initiated
     * @type {string}
     * @memberof PaymentEntity
     */
    'payment_time'?: string;
    /**
     * This is the time when the payment reaches its terminal state
     * @type {string}
     * @memberof PaymentEntity
     */
    'payment_completion_time'?: string;
    /**
     * The transaction status can be one of  [\"SUCCESS\", \"NOT_ATTEMPTED\", \"FAILED\", \"USER_DROPPED\", \"VOID\", \"CANCELLED\", \"PENDING\"]
     * @type {string}
     * @memberof PaymentEntity
     */
    'payment_status'?: PaymentEntityPaymentStatusEnum;
    /**
     *
     * @type {string}
     * @memberof PaymentEntity
     */
    'payment_message'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentEntity
     */
    'bank_reference'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentEntity
     */
    'auth_id'?: string;
    /**
     *
     * @type {AuthorizationInPaymentsEntity}
     * @memberof PaymentEntity
     */
    'authorization'?: AuthorizationInPaymentsEntity;
    /**
     *
     * @type {PaymentEntityPaymentMethod}
     * @memberof PaymentEntity
     */
    'payment_method'?: PaymentEntityPaymentMethod;
}
export declare const PaymentEntityPaymentStatusEnum: {
    readonly SUCCESS: "SUCCESS";
    readonly NOT_ATTEMPTED: "NOT_ATTEMPTED";
    readonly FAILED: "FAILED";
    readonly USER_DROPPED: "USER_DROPPED";
    readonly VOID: "VOID";
    readonly CANCELLED: "CANCELLED";
    readonly PENDING: "PENDING";
    readonly UNKNOWN_DEFAULT_OPEN_API: "11184809";
};
export type PaymentEntityPaymentStatusEnum = typeof PaymentEntityPaymentStatusEnum[keyof typeof PaymentEntityPaymentStatusEnum];
/**
 * @type PaymentEntityPaymentMethod
 * @export
 */
export type PaymentEntityPaymentMethod = PaymentMethodAppInPaymentsEntity | PaymentMethodCardEMIInPaymentsEntity | PaymentMethodCardInPaymentsEntity | PaymentMethodCardlessEMIInPaymentsEntity | PaymentMethodNetBankingInPaymentsEntity | PaymentMethodPaylaterInPaymentsEntity | PaymentMethodUPIInPaymentsEntity;
/**
 * The customer details that are necessary. Note that you can pass dummy details if your use case does not require the customer details.
 * @export
 * @interface PaymentLinkCustomerDetails
 */
export interface PaymentLinkCustomerDetails {
    /**
     * A unique identifier for the customer. Use alphanumeric values only.
     * @type {string}
     * @memberof PaymentLinkCustomerDetails
     */
    'customer_id'?: string;
    /**
     * Customer email address.
     * @type {string}
     * @memberof PaymentLinkCustomerDetails
     */
    'customer_email'?: string;
    /**
     * Customer phone number.
     * @type {string}
     * @memberof PaymentLinkCustomerDetails
     */
    'customer_phone': string;
    /**
     * Name of the customer.
     * @type {string}
     * @memberof PaymentLinkCustomerDetails
     */
    'customer_name'?: string;
    /**
     * Customer bank account. Required if you want to do a bank account check (TPV)
     * @type {string}
     * @memberof PaymentLinkCustomerDetails
     */
    'customer_bank_account_number'?: string;
    /**
     * Customer bank IFSC. Required if you want to do a bank account check (TPV)
     * @type {string}
     * @memberof PaymentLinkCustomerDetails
     */
    'customer_bank_ifsc'?: string;
    /**
     * Customer bank code. Required for net banking payments, if you want to do a bank account check (TPV)
     * @type {number}
     * @memberof PaymentLinkCustomerDetails
     */
    'customer_bank_code'?: number;
}
/**
 * The complete order entity
 * @export
 * @interface PaymentLinkOrderEntity
 */
export interface PaymentLinkOrderEntity {
    /**
     * unique id generated by cashfree for your order
     * @type {string}
     * @memberof PaymentLinkOrderEntity
     */
    'cf_order_id'?: string;
    /**
     * link id of the order
     * @type {string}
     * @memberof PaymentLinkOrderEntity
     */
    'link_id'?: string;
    /**
     * order_id sent during the api request
     * @type {string}
     * @memberof PaymentLinkOrderEntity
     */
    'order_id'?: string;
    /**
     * Type of the entity.
     * @type {string}
     * @memberof PaymentLinkOrderEntity
     */
    'entity'?: string;
    /**
     * Currency of the order. Example INR
     * @type {string}
     * @memberof PaymentLinkOrderEntity
     */
    'order_currency'?: string;
    /**
     *
     * @type {number}
     * @memberof PaymentLinkOrderEntity
     */
    'order_amount'?: number;
    /**
     * Possible values are  - `ACTIVE`: Order does not have a sucessful transaction yet - `PAID`: Order is PAID with one successful transaction - `EXPIRED`: Order was not PAID and not it has expired. No transaction can be initiated for an EXPIRED order.
     * @type {string}
     * @memberof PaymentLinkOrderEntity
     */
    'order_status'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentLinkOrderEntity
     */
    'payment_session_id'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentLinkOrderEntity
     */
    'order_expiry_time'?: string;
    /**
     * Additional note for order
     * @type {string}
     * @memberof PaymentLinkOrderEntity
     */
    'order_note'?: string;
    /**
     * When the order was created at cashfree\'s server
     * @type {string}
     * @memberof PaymentLinkOrderEntity
     */
    'created_at'?: string;
    /**
     *
     * @type {Array<VendorSplit>}
     * @memberof PaymentLinkOrderEntity
     */
    'order_splits'?: Array<VendorSplit>;
    /**
     *
     * @type {PaymentLinkCustomerDetails}
     * @memberof PaymentLinkOrderEntity
     */
    'customer_details'?: PaymentLinkCustomerDetails;
    /**
     *
     * @type {OrderMeta}
     * @memberof PaymentLinkOrderEntity
     */
    'order_meta'?: OrderMeta;
    /**
     * Custom Tags in thr form of {\"key\":\"value\"} which can be passed for an order. A maximum of 10 tags can be added
     * @type {{ [key: string]: string; }}
     * @memberof PaymentLinkOrderEntity
     */
    'order_tags'?: {
        [key: string]: string;
    };
}
/**
 * payment method app object in payment entity
 * @export
 * @interface PaymentMethodAppInPaymentsEntity
 */
export interface PaymentMethodAppInPaymentsEntity {
    /**
     *
     * @type {PaymentMethodAppInPaymentsEntityApp}
     * @memberof PaymentMethodAppInPaymentsEntity
     */
    'app'?: PaymentMethodAppInPaymentsEntityApp;
}
/**
 *
 * @export
 * @interface PaymentMethodAppInPaymentsEntityApp
 */
export interface PaymentMethodAppInPaymentsEntityApp {
    /**
     *
     * @type {string}
     * @memberof PaymentMethodAppInPaymentsEntityApp
     */
    'channel'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentMethodAppInPaymentsEntityApp
     */
    'provider'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentMethodAppInPaymentsEntityApp
     */
    'phone'?: string;
}
/**
 * payment method card emi object in payment entity
 * @export
 * @interface PaymentMethodCardEMIInPaymentsEntity
 */
export interface PaymentMethodCardEMIInPaymentsEntity {
    /**
     *
     * @type {PaymentMethodCardEMIInPaymentsEntityEmi}
     * @memberof PaymentMethodCardEMIInPaymentsEntity
     */
    'emi'?: PaymentMethodCardEMIInPaymentsEntityEmi;
}
/**
 *
 * @export
 * @interface PaymentMethodCardEMIInPaymentsEntityEmi
 */
export interface PaymentMethodCardEMIInPaymentsEntityEmi {
    /**
     *
     * @type {string}
     * @memberof PaymentMethodCardEMIInPaymentsEntityEmi
     */
    'channel'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentMethodCardEMIInPaymentsEntityEmi
     */
    'card_number'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentMethodCardEMIInPaymentsEntityEmi
     */
    'card_network'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentMethodCardEMIInPaymentsEntityEmi
     */
    'card_type'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentMethodCardEMIInPaymentsEntityEmi
     */
    'card_country'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentMethodCardEMIInPaymentsEntityEmi
     */
    'card_bank_name'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentMethodCardEMIInPaymentsEntityEmi
     */
    'card_network_reference_id'?: string;
    /**
     *
     * @type {number}
     * @memberof PaymentMethodCardEMIInPaymentsEntityEmi
     */
    'emi_tenure'?: number;
    /**
     *
     * @type {PaymentMethodCardEMIInPaymentsEntityEmiEmiDetails}
     * @memberof PaymentMethodCardEMIInPaymentsEntityEmi
     */
    'emi_details'?: PaymentMethodCardEMIInPaymentsEntityEmiEmiDetails;
}
/**
 *
 * @export
 * @interface PaymentMethodCardEMIInPaymentsEntityEmiEmiDetails
 */
export interface PaymentMethodCardEMIInPaymentsEntityEmiEmiDetails {
    /**
     *
     * @type {number}
     * @memberof PaymentMethodCardEMIInPaymentsEntityEmiEmiDetails
     */
    'emi_amount'?: number;
    /**
     *
     * @type {number}
     * @memberof PaymentMethodCardEMIInPaymentsEntityEmiEmiDetails
     */
    'emi_tenure'?: number;
    /**
     *
     * @type {number}
     * @memberof PaymentMethodCardEMIInPaymentsEntityEmiEmiDetails
     */
    'emi_interest'?: number;
}
/**
 * payment method card object in payment entity
 * @export
 * @interface PaymentMethodCardInPaymentsEntity
 */
export interface PaymentMethodCardInPaymentsEntity {
    /**
     *
     * @type {PaymentMethodCardInPaymentsEntityCard}
     * @memberof PaymentMethodCardInPaymentsEntity
     */
    'card'?: PaymentMethodCardInPaymentsEntityCard;
}
/**
 *
 * @export
 * @interface PaymentMethodCardInPaymentsEntityCard
 */
export interface PaymentMethodCardInPaymentsEntityCard {
    /**
     *
     * @type {string}
     * @memberof PaymentMethodCardInPaymentsEntityCard
     */
    'channel'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentMethodCardInPaymentsEntityCard
     */
    'card_number'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentMethodCardInPaymentsEntityCard
     */
    'card_network'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentMethodCardInPaymentsEntityCard
     */
    'card_type'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentMethodCardInPaymentsEntityCard
     */
    'card_country'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentMethodCardInPaymentsEntityCard
     */
    'card_bank_name'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentMethodCardInPaymentsEntityCard
     */
    'card_network_reference_id'?: string;
}
/**
 * payment method carless object in payment entity
 * @export
 * @interface PaymentMethodCardlessEMIInPaymentsEntity
 */
export interface PaymentMethodCardlessEMIInPaymentsEntity {
    /**
     *
     * @type {PaymentMethodAppInPaymentsEntityApp}
     * @memberof PaymentMethodCardlessEMIInPaymentsEntity
     */
    'cardless_emi'?: PaymentMethodAppInPaymentsEntityApp;
}
/**
 * netbanking payment method object for pay
 * @export
 * @interface PaymentMethodNetBankingInPaymentsEntity
 */
export interface PaymentMethodNetBankingInPaymentsEntity {
    /**
     *
     * @type {PaymentMethodNetBankingInPaymentsEntityNetbanking}
     * @memberof PaymentMethodNetBankingInPaymentsEntity
     */
    'netbanking'?: PaymentMethodNetBankingInPaymentsEntityNetbanking;
}
/**
 *
 * @export
 * @interface PaymentMethodNetBankingInPaymentsEntityNetbanking
 */
export interface PaymentMethodNetBankingInPaymentsEntityNetbanking {
    /**
     *
     * @type {string}
     * @memberof PaymentMethodNetBankingInPaymentsEntityNetbanking
     */
    'channel'?: string;
    /**
     *
     * @type {number}
     * @memberof PaymentMethodNetBankingInPaymentsEntityNetbanking
     */
    'netbanking_bank_code'?: number;
    /**
     *
     * @type {string}
     * @memberof PaymentMethodNetBankingInPaymentsEntityNetbanking
     */
    'netbanking_bank_name'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentMethodNetBankingInPaymentsEntityNetbanking
     */
    'netbanking_ifsc'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentMethodNetBankingInPaymentsEntityNetbanking
     */
    'netbanking_account_number'?: string;
}
/**
 * paylater payment method object for pay api
 * @export
 * @interface PaymentMethodPaylaterInPaymentsEntity
 */
export interface PaymentMethodPaylaterInPaymentsEntity {
    /**
     *
     * @type {PaymentMethodAppInPaymentsEntityApp}
     * @memberof PaymentMethodPaylaterInPaymentsEntity
     */
    'paylater'?: PaymentMethodAppInPaymentsEntityApp;
}
/**
 * UPI payment method for pay api
 * @export
 * @interface PaymentMethodUPIInPaymentsEntity
 */
export interface PaymentMethodUPIInPaymentsEntity {
    /**
     *
     * @type {PaymentMethodUPIInPaymentsEntityUpi}
     * @memberof PaymentMethodUPIInPaymentsEntity
     */
    'upi'?: PaymentMethodUPIInPaymentsEntityUpi;
}
/**
 *
 * @export
 * @interface PaymentMethodUPIInPaymentsEntityUpi
 */
export interface PaymentMethodUPIInPaymentsEntityUpi {
    /**
     *
     * @type {string}
     * @memberof PaymentMethodUPIInPaymentsEntityUpi
     */
    'channel'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentMethodUPIInPaymentsEntityUpi
     */
    'upi_id'?: string;
}
/**
 * Filter for Payment Methods
 * @export
 * @interface PaymentMethodsFilters
 */
export interface PaymentMethodsFilters {
    /**
     * Array of payment methods to be filtered. This is optional, by default all payment methods will be returned. Possible values in [ \'debit_card\', \'credit_card\', \'prepaid_card\', \'corporate_credit_card\', \'upi\', \'wallet\', \'netbanking\', \'banktransfer\', \'paylater\', \'paypal\', \'debit_card_emi\', \'credit_card_emi\', \'upi_credit_card\', \'upi_ppi\', \'cardless_emi\', \'account_based_payment\' ]
     * @type {Array<string>}
     * @memberof PaymentMethodsFilters
     */
    'payment_methods'?: Array<string>;
}
/**
 * Payment Method Query Object
 * @export
 * @interface PaymentMethodsQueries
 */
export interface PaymentMethodsQueries {
    /**
     * Amount of the order.
     * @type {number}
     * @memberof PaymentMethodsQueries
     */
    'amount'?: number;
    /**
     * OrderId of the order. Either of `order_id` or `order_amount` is mandatory.
     * @type {string}
     * @memberof PaymentMethodsQueries
     */
    'order_id'?: string;
}
/**
 * payment mode eligiblity object
 * @export
 * @interface PaymentModeDetails
 */
export interface PaymentModeDetails {
    /**
     *
     * @type {string}
     * @memberof PaymentModeDetails
     */
    'nick'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentModeDetails
     */
    'display'?: string;
    /**
     *
     * @type {boolean}
     * @memberof PaymentModeDetails
     */
    'eligibility'?: boolean;
    /**
     *
     * @type {number}
     * @memberof PaymentModeDetails
     */
    'code'?: number;
}
/**
 * payment webhook object
 * @export
 * @interface PaymentWebhook
 */
export interface PaymentWebhook {
    /**
     *
     * @type {PaymentWebhookDataEntity}
     * @memberof PaymentWebhook
     */
    'data'?: PaymentWebhookDataEntity;
    /**
     *
     * @type {string}
     * @memberof PaymentWebhook
     */
    'event_time'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentWebhook
     */
    'type'?: string;
}
/**
 * customer details object in webhook
 * @export
 * @interface PaymentWebhookCustomerEntity
 */
export interface PaymentWebhookCustomerEntity {
    /**
     *
     * @type {string}
     * @memberof PaymentWebhookCustomerEntity
     */
    'customer_name'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentWebhookCustomerEntity
     */
    'customer_id'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentWebhookCustomerEntity
     */
    'customer_email'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentWebhookCustomerEntity
     */
    'customer_phone'?: string;
}
/**
 * data entity in webhook
 * @export
 * @interface PaymentWebhookDataEntity
 */
export interface PaymentWebhookDataEntity {
    /**
     *
     * @type {PaymentWebhookOrderEntity}
     * @memberof PaymentWebhookDataEntity
     */
    'order'?: PaymentWebhookOrderEntity;
    /**
     *
     * @type {PaymentEntity}
     * @memberof PaymentWebhookDataEntity
     */
    'payment'?: PaymentEntity;
    /**
     *
     * @type {PaymentWebhookCustomerEntity}
     * @memberof PaymentWebhookDataEntity
     */
    'customer_details'?: PaymentWebhookCustomerEntity;
    /**
     *
     * @type {PaymentWebhookErrorEntity}
     * @memberof PaymentWebhookDataEntity
     */
    'error_details'?: PaymentWebhookErrorEntity;
    /**
     *
     * @type {PaymentWebhookGatewayDetailsEntity}
     * @memberof PaymentWebhookDataEntity
     */
    'payment_gateway_details'?: PaymentWebhookGatewayDetailsEntity;
    /**
     *
     * @type {Array<OfferEntity>}
     * @memberof PaymentWebhookDataEntity
     */
    'payment_offers'?: Array<OfferEntity>;
}
/**
 * error details present in the webhook
 * @export
 * @interface PaymentWebhookErrorEntity
 */
export interface PaymentWebhookErrorEntity {
    /**
     *
     * @type {string}
     * @memberof PaymentWebhookErrorEntity
     */
    'error_code'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentWebhookErrorEntity
     */
    'error_description'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentWebhookErrorEntity
     */
    'error_reason'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentWebhookErrorEntity
     */
    'error_source'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentWebhookErrorEntity
     */
    'error_code_raw'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentWebhookErrorEntity
     */
    'error_description_raw'?: string;
}
/**
 * payment gatewat details present in the webhook response
 * @export
 * @interface PaymentWebhookGatewayDetailsEntity
 */
export interface PaymentWebhookGatewayDetailsEntity {
    /**
     *
     * @type {string}
     * @memberof PaymentWebhookGatewayDetailsEntity
     */
    'gateway_name'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentWebhookGatewayDetailsEntity
     */
    'gateway_order_id'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentWebhookGatewayDetailsEntity
     */
    'gateway_payment_id'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentWebhookGatewayDetailsEntity
     */
    'gateway_status_code'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentWebhookGatewayDetailsEntity
     */
    'gateway_settlement'?: string;
}
/**
 * order entity in webhook
 * @export
 * @interface PaymentWebhookOrderEntity
 */
export interface PaymentWebhookOrderEntity {
    /**
     *
     * @type {string}
     * @memberof PaymentWebhookOrderEntity
     */
    'order_id'?: string;
    /**
     *
     * @type {number}
     * @memberof PaymentWebhookOrderEntity
     */
    'order_amount'?: number;
    /**
     *
     * @type {string}
     * @memberof PaymentWebhookOrderEntity
     */
    'order_currency'?: string;
    /**
     * Custom Tags in thr form of {\"key\":\"value\"} which can be passed for an order. A maximum of 10 tags can be added
     * @type {{ [key: string]: string; }}
     * @memberof PaymentWebhookOrderEntity
     */
    'order_tags'?: {
        [key: string]: string;
    };
}
/**
 * Error when rate limit is breached for your api
 * @export
 * @interface RateLimitError
 */
export interface RateLimitError {
    /**
     *
     * @type {string}
     * @memberof RateLimitError
     */
    'message'?: string;
    /**
     *
     * @type {string}
     * @memberof RateLimitError
     */
    'code'?: string;
    /**
     * rate_limit_error
     * @type {string}
     * @memberof RateLimitError
     */
    'type'?: RateLimitErrorTypeEnum;
}
export declare const RateLimitErrorTypeEnum: {
    readonly RATE_LIMIT_ERROR: "rate_limit_error";
    readonly UNKNOWN_DEFAULT_OPEN_API: "11184809";
};
export type RateLimitErrorTypeEnum = typeof RateLimitErrorTypeEnum[keyof typeof RateLimitErrorTypeEnum];
/**
 * Settlement detailed recon response
 * @export
 * @interface ReconEntity
 */
export interface ReconEntity {
    /**
     * Specifies from where the next set of settlement details should be fetched.
     * @type {string}
     * @memberof ReconEntity
     */
    'cursor'?: string;
    /**
     * Number of settlements you want to fetch in the next iteration.
     * @type {number}
     * @memberof ReconEntity
     */
    'limit'?: number;
    /**
     *
     * @type {Array<ReconEntityDataInner>}
     * @memberof ReconEntity
     */
    'data'?: Array<ReconEntityDataInner>;
}
/**
 *
 * @export
 * @interface ReconEntityDataInner
 */
export interface ReconEntityDataInner {
    /**
     * Unique ID associated with the event.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'event_id'?: string;
    /**
     * The event type can be SETTLEMENT, PAYMENT, REFUND, REFUND_REVERSAL, DISPUTE, DISPUTE_REVERSAL, CHARGEBACK, CHARGEBACK_REVERSAL, OTHER_ADJUSTMENT.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'event_type'?: string;
    /**
     * Amount that is part of the settlement corresponding to the event.
     * @type {number}
     * @memberof ReconEntityDataInner
     */
    'event_settlement_amount'?: number;
    /**
     * Amount of the event. Example, refund amount, dispute amount, payment amount, etc.
     * @type {number}
     * @memberof ReconEntityDataInner
     */
    'event_amount'?: number;
    /**
     * Indicates if it is CREDIT/DEBIT sale.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'sale_type'?: string;
    /**
     * Status of the event. Example - SUCCESS, FAILED, PENDING, CANCELLED.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'event_status'?: string;
    /**
     * Recon
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'entity'?: string;
    /**
     * Time associated with the event. Example, transaction time, dispute initiation time
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'event_time'?: string;
    /**
     * Curreny type - INR.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'event_currency'?: string;
    /**
     * Unique order ID. Alphanumeric and only \'-\' and \'_\' allowed.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'order_id'?: string;
    /**
     * The amount which was passed at the order creation time.
     * @type {number}
     * @memberof ReconEntityDataInner
     */
    'order_amount'?: number;
    /**
     * Customer phone number.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'customer_phone'?: string;
    /**
     * Customer email.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'customer_email'?: string;
    /**
     * Customer name.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'customer_name'?: string;
    /**
     * Payment amount captured.
     * @type {number}
     * @memberof ReconEntityDataInner
     */
    'payment_amount'?: number;
    /**
     * Unique transaction reference number of the payment.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'payment_utr'?: string;
    /**
     * Date and time when the payment was initiated.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'payment_time'?: string;
    /**
     * Service charge applicable for the payment.
     * @type {number}
     * @memberof ReconEntityDataInner
     */
    'payment_service_charge'?: number;
    /**
     * Service tax applicable on the payment.
     * @type {number}
     * @memberof ReconEntityDataInner
     */
    'payment_service_tax'?: number;
    /**
     * Cashfree Payments unique ID to identify a payment.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'cf_payment_id'?: string;
    /**
     * Unique ID to identify the settlement.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'cf_settlement_id'?: string;
    /**
     * Date and time when the settlement was processed.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'settlement_date'?: string;
    /**
     * Unique transaction reference number of the settlement.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'settlement_utr'?: string;
    /**
     * Service charge that is applicable for splitting the payment.
     * @type {number}
     * @memberof ReconEntityDataInner
     */
    'split_service_charge'?: number;
    /**
     * Service tax applicable for splitting the amount to vendors.
     * @type {number}
     * @memberof ReconEntityDataInner
     */
    'split_service_tax'?: number;
    /**
     * Vendor commission applicable for this transaction.
     * @type {number}
     * @memberof ReconEntityDataInner
     */
    'vendor_commission'?: number;
    /**
     * Specifies whether the dispute was closed in favor of the merchant or customer. /n Possible values - Merchant, Customer
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'closed_in_favor_of'?: string;
    /**
     * Date and time when the dispute was resolved.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'dispute_resolved_on'?: string;
    /**
     * Category of the dispute - Dispute code and the reason for dispute is shown.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'dispute_category'?: string;
    /**
     * Note regarding the dispute.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'dispute_note'?: string;
    /**
     * Date and time when the refund was processed.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'refund_processed_at'?: string;
    /**
     * The bank reference number for the refund.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'refund_arn'?: string;
    /**
     * A refund note for your reference.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'refund_note'?: string;
    /**
     * An unique ID to associate the refund with.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'refund_id'?: string;
    /**
     * Other adjustment remarks.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'adjustment_remarks'?: string;
    /**
     * Amount that is adjusted from the settlement amount because of any credit/debit event such as refund, refund_reverse etc.
     * @type {number}
     * @memberof ReconEntityDataInner
     */
    'adjustment'?: number;
    /**
     * Service tax applicable on the settlement amount.
     * @type {number}
     * @memberof ReconEntityDataInner
     */
    'service_tax'?: number;
    /**
     * Service charge applicable on the settlement amount.
     * @type {number}
     * @memberof ReconEntityDataInner
     */
    'service_charge'?: number;
    /**
     * Net amount that is settled after considering the adjustments, settlement charge and tax.
     * @type {number}
     * @memberof ReconEntityDataInner
     */
    'amount_settled'?: number;
    /**
     * The start time of the time range of the payments considered for the settlement.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'payment_from'?: string;
    /**
     * The end time of time range of the payments considered for the settlement.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'payment_till'?: string;
    /**
     * Reason for settlement failure.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'reason'?: string;
    /**
     * Date and time when the settlement was initiated.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'settlement_initiated_on'?: string;
    /**
     * Type of settlement. Possible values - Standard, Instant, On demand.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'settlement_type'?: string;
    /**
     * Settlement charges applicable on the settlement.
     * @type {number}
     * @memberof ReconEntityDataInner
     */
    'settlement_charge'?: number;
    /**
     * Settlement tax applicable on the settlement.
     * @type {number}
     * @memberof ReconEntityDataInner
     */
    'settlement_tax'?: number;
    /**
     * Remarks on the settlement.
     * @type {string}
     * @memberof ReconEntityDataInner
     */
    'remarks'?: string;
}
/**
 * The refund entity
 * @export
 * @interface RefundEntity
 */
export interface RefundEntity {
    /**
     * Cashfree Payments ID of the payment for which refund is initiated
     * @type {string}
     * @memberof RefundEntity
     */
    'cf_payment_id'?: string;
    /**
     * Cashfree Payments ID for a refund
     * @type {string}
     * @memberof RefundEntity
     */
    'cf_refund_id'?: string;
    /**
     * Merchant’s order Id of the order for which refund is initiated
     * @type {string}
     * @memberof RefundEntity
     */
    'order_id'?: string;
    /**
     * Merchant’s refund ID of the refund
     * @type {string}
     * @memberof RefundEntity
     */
    'refund_id'?: string;
    /**
     * Type of object
     * @type {string}
     * @memberof RefundEntity
     */
    'entity'?: RefundEntityEntityEnum;
    /**
     * Amount that is refunded
     * @type {number}
     * @memberof RefundEntity
     */
    'refund_amount'?: number;
    /**
     * Currency of the refund amount
     * @type {string}
     * @memberof RefundEntity
     */
    'refund_currency'?: string;
    /**
     * Note added by merchant for the refund
     * @type {string}
     * @memberof RefundEntity
     */
    'refund_note'?: string;
    /**
     * This can be one of [\"SUCCESS\", \"PENDING\", \"CANCELLED\", \"ONHOLD\", \"FAILED\"]
     * @type {string}
     * @memberof RefundEntity
     */
    'refund_status'?: RefundEntityRefundStatusEnum;
    /**
     * The bank reference number for refund
     * @type {string}
     * @memberof RefundEntity
     */
    'refund_arn'?: string;
    /**
     * Charges in INR for processing refund
     * @type {number}
     * @memberof RefundEntity
     */
    'refund_charge'?: number;
    /**
     * Description of refund status
     * @type {string}
     * @memberof RefundEntity
     */
    'status_description'?: string;
    /**
     * Key-value pair that can be used to store additional information about the entity. Maximum 5 key-value pairs
     * @type {object}
     * @memberof RefundEntity
     */
    'metadata'?: object;
    /**
     *
     * @type {Array<VendorSplit>}
     * @memberof RefundEntity
     */
    'refund_splits'?: Array<VendorSplit>;
    /**
     * This can be one of [\"PAYMENT_AUTO_REFUND\", \"MERCHANT_INITIATED\", \"UNRECONCILED_AUTO_REFUND\"]
     * @type {string}
     * @memberof RefundEntity
     */
    'refund_type'?: RefundEntityRefundTypeEnum;
    /**
     * Method or speed of processing refund
     * @type {string}
     * @memberof RefundEntity
     */
    'refund_mode'?: RefundEntityRefundModeEnum;
    /**
     * Time of refund creation
     * @type {string}
     * @memberof RefundEntity
     */
    'created_at'?: string;
    /**
     * Time when refund was processed successfully
     * @type {string}
     * @memberof RefundEntity
     */
    'processed_at'?: string;
    /**
     *
     * @type {RefundSpeed}
     * @memberof RefundEntity
     */
    'refund_speed'?: RefundSpeed;
}
export declare const RefundEntityEntityEnum: {
    readonly REFUND: "refund";
    readonly UNKNOWN_DEFAULT_OPEN_API: "11184809";
};
export type RefundEntityEntityEnum = typeof RefundEntityEntityEnum[keyof typeof RefundEntityEntityEnum];
export declare const RefundEntityRefundStatusEnum: {
    readonly SUCCESS: "SUCCESS";
    readonly PENDING: "PENDING";
    readonly CANCELLED: "CANCELLED";
    readonly ONHOLD: "ONHOLD";
    readonly UNKNOWN_DEFAULT_OPEN_API: "11184809";
};
export type RefundEntityRefundStatusEnum = typeof RefundEntityRefundStatusEnum[keyof typeof RefundEntityRefundStatusEnum];
export declare const RefundEntityRefundTypeEnum: {
    readonly PAYMENT_AUTO_REFUND: "PAYMENT_AUTO_REFUND";
    readonly MERCHANT_INITIATED: "MERCHANT_INITIATED";
    readonly UNRECONCILED_AUTO_REFUND: "UNRECONCILED_AUTO_REFUND";
    readonly UNKNOWN_DEFAULT_OPEN_API: "11184809";
};
export type RefundEntityRefundTypeEnum = typeof RefundEntityRefundTypeEnum[keyof typeof RefundEntityRefundTypeEnum];
export declare const RefundEntityRefundModeEnum: {
    readonly STANDARD: "STANDARD";
    readonly INSTANT: "INSTANT";
    readonly UNKNOWN_DEFAULT_OPEN_API: "11184809";
};
export type RefundEntityRefundModeEnum = typeof RefundEntityRefundModeEnum[keyof typeof RefundEntityRefundModeEnum];
/**
 * How fast refund has to be proecessed
 * @export
 * @interface RefundSpeed
 */
export interface RefundSpeed {
    /**
     * Requested speed of refund.
     * @type {string}
     * @memberof RefundSpeed
     */
    'requested'?: string;
    /**
     * Accepted speed of refund.
     * @type {string}
     * @memberof RefundSpeed
     */
    'accepted'?: string;
    /**
     * Processed speed of refund.
     * @type {string}
     * @memberof RefundSpeed
     */
    'processed'?: string;
    /**
     * Error message, if any for refund_speed request
     * @type {string}
     * @memberof RefundSpeed
     */
    'message'?: string;
}
/**
 * refund webhook object
 * @export
 * @interface RefundWebhook
 */
export interface RefundWebhook {
    /**
     *
     * @type {RefundWebhookDataEntity}
     * @memberof RefundWebhook
     */
    'data'?: RefundWebhookDataEntity;
    /**
     *
     * @type {string}
     * @memberof RefundWebhook
     */
    'event_time'?: string;
    /**
     *
     * @type {string}
     * @memberof RefundWebhook
     */
    'type'?: string;
}
/**
 * data entity in webhook
 * @export
 * @interface RefundWebhookDataEntity
 */
export interface RefundWebhookDataEntity {
    /**
     *
     * @type {RefundEntity}
     * @memberof RefundWebhookDataEntity
     */
    'refund'?: RefundEntity;
}
/**
 * Card instrument meta information
 * @export
 * @interface SavedInstrumentMeta
 */
export interface SavedInstrumentMeta {
    /**
     * card scheme/network of the saved card. Example visa, mastercard
     * @type {string}
     * @memberof SavedInstrumentMeta
     */
    'card_network'?: string;
    /**
     * Issuing bank name of saved card
     * @type {string}
     * @memberof SavedInstrumentMeta
     */
    'card_bank_name'?: string;
    /**
     * Issuing country of saved card
     * @type {string}
     * @memberof SavedInstrumentMeta
     */
    'card_country'?: string;
    /**
     * Type of saved card
     * @type {string}
     * @memberof SavedInstrumentMeta
     */
    'card_type'?: string;
    /**
     *
     * @type {object}
     * @memberof SavedInstrumentMeta
     */
    'card_token_details'?: object;
}
/**
 * Settlement entity object
 * @export
 * @interface SettlementEntity
 */
export interface SettlementEntity {
    /**
     *
     * @type {string}
     * @memberof SettlementEntity
     */
    'cf_payment_id'?: string;
    /**
     *
     * @type {string}
     * @memberof SettlementEntity
     */
    'cf_settlement_id'?: string;
    /**
     *
     * @type {string}
     * @memberof SettlementEntity
     */
    'settlement_currency'?: string;
    /**
     *
     * @type {string}
     * @memberof SettlementEntity
     */
    'order_id'?: string;
    /**
     *
     * @type {string}
     * @memberof SettlementEntity
     */
    'entity'?: string;
    /**
     *
     * @type {number}
     * @memberof SettlementEntity
     */
    'order_amount'?: number;
    /**
     *
     * @type {string}
     * @memberof SettlementEntity
     */
    'payment_time'?: string;
    /**
     *
     * @type {number}
     * @memberof SettlementEntity
     */
    'service_charge'?: number;
    /**
     *
     * @type {number}
     * @memberof SettlementEntity
     */
    'service_tax'?: number;
    /**
     *
     * @type {number}
     * @memberof SettlementEntity
     */
    'settlement_amount'?: number;
    /**
     *
     * @type {number}
     * @memberof SettlementEntity
     */
    'settlement_id'?: number;
    /**
     *
     * @type {number}
     * @memberof SettlementEntity
     */
    'transfer_id'?: number;
    /**
     *
     * @type {string}
     * @memberof SettlementEntity
     */
    'transfer_time'?: string;
    /**
     *
     * @type {string}
     * @memberof SettlementEntity
     */
    'transfer_utr'?: string;
}
/**
 * Recon Request Object
 * @export
 * @interface SettlementFetchReconRequest
 */
export interface SettlementFetchReconRequest {
    /**
     *
     * @type {FetchSettlementsRequestPagination}
     * @memberof SettlementFetchReconRequest
     */
    'pagination': FetchSettlementsRequestPagination;
    /**
     *
     * @type {FetchSettlementsRequestFilters}
     * @memberof SettlementFetchReconRequest
     */
    'filters': FetchSettlementsRequestFilters;
}
/**
 * Recon object for settlement
 * @export
 * @interface SettlementReconEntity
 */
export interface SettlementReconEntity {
    /**
     * Specifies from where the next set of settlement details should be fetched.
     * @type {string}
     * @memberof SettlementReconEntity
     */
    'cursor'?: string;
    /**
     * Number of settlements you want to fetch in the next iteration.
     * @type {number}
     * @memberof SettlementReconEntity
     */
    'limit'?: number;
    /**
     *
     * @type {Array<SettlementReconEntityDataInner>}
     * @memberof SettlementReconEntity
     */
    'data'?: Array<SettlementReconEntityDataInner>;
}
/**
 *
 * @export
 * @interface SettlementReconEntityDataInner
 */
export interface SettlementReconEntityDataInner {
    /**
     * Unique ID associated with the event.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'event_id'?: string;
    /**
     * The event type can be PAYMENT, REFUND, REFUND_REVERSAL, DISPUTE, DISPUTE_REVERSAL, CHARGEBACK, CHARGEBACK_REVERSAL, OTHER_ADJUSTMENT.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'event_type'?: string;
    /**
     * Amount that is part of the settlement corresponding to the event.
     * @type {number}
     * @memberof SettlementReconEntityDataInner
     */
    'event_settlement_amount'?: number;
    /**
     * Amount corresponding to the event. Example, refund amount, dispute amount, payment amount, etc.
     * @type {number}
     * @memberof SettlementReconEntityDataInner
     */
    'event_amount'?: number;
    /**
     * Indicates if it is CREDIT/DEBIT sale.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'sale_type'?: string;
    /**
     * Status of the event. Example - SUCCESS, FAILED, PENDING, CANCELLED.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'event_status'?: string;
    /**
     * Recon
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'entity'?: string;
    /**
     * Time associated with the event. Example, transaction time, dispute initiation time
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'event_time'?: string;
    /**
     * Curreny type - INR.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'event_currency'?: string;
    /**
     * Unique order ID. Alphanumeric and only \'-\' and \'_\' allowed.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'order_id'?: string;
    /**
     * The amount which was passed at the order creation time.
     * @type {number}
     * @memberof SettlementReconEntityDataInner
     */
    'order_amount'?: number;
    /**
     * Customer phone number.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'customer_phone'?: string;
    /**
     * Customer email.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'customer_email'?: string;
    /**
     * Customer name.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'customer_name'?: string;
    /**
     * Payment amount captured.
     * @type {number}
     * @memberof SettlementReconEntityDataInner
     */
    'payment_amount'?: number;
    /**
     * Unique transaction reference number of the payment.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'payment_utr'?: string;
    /**
     * Date and time when the payment was initiated.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'payment_time'?: string;
    /**
     * Service charge applicable for the payment.
     * @type {number}
     * @memberof SettlementReconEntityDataInner
     */
    'payment_service_charge'?: number;
    /**
     * Service tax applicable on the payment.
     * @type {number}
     * @memberof SettlementReconEntityDataInner
     */
    'payment_service_tax'?: number;
    /**
     * Cashfree Payments unique ID to identify a payment.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'cf_payment_id'?: string;
    /**
     * Unique ID to identify the settlement.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'cf_settlement_id'?: string;
    /**
     * Date and time when the settlement was processed.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'settlement_date'?: string;
    /**
     * Unique transaction reference number of the settlement.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'settlement_utr'?: string;
    /**
     * Service charge that is applicable for splitting the payment.
     * @type {number}
     * @memberof SettlementReconEntityDataInner
     */
    'split_service_charge'?: number;
    /**
     * Service tax applicable for splitting the amount to vendors.
     * @type {number}
     * @memberof SettlementReconEntityDataInner
     */
    'split_service_tax'?: number;
    /**
     * Vendor commission applicable for this transaction.
     * @type {number}
     * @memberof SettlementReconEntityDataInner
     */
    'vendor_commission'?: number;
    /**
     * Specifies whether the dispute was closed in favor of the merchant or customer. Possible values - Merchant, Customer.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'closed_in_favor_of'?: string;
    /**
     * Date and time when the dispute was resolved.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'dispute_resolved_on'?: string;
    /**
     * Category of the dispute - Dispute code and the reason for dispute is shown.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'dispute_category'?: string;
    /**
     * Note regarding the dispute.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'dispute_note'?: string;
    /**
     * Date and time when the refund was processed.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'refund_processed_at'?: string;
    /**
     * The bank reference number for refund.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'refund_arn'?: string;
    /**
     * A refund note for your reference.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'refund_note'?: string;
    /**
     * An unique ID associated with the refund.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'refund_id'?: string;
    /**
     * Other adjustment remarks.
     * @type {string}
     * @memberof SettlementReconEntityDataInner
     */
    'adjustment_remarks'?: string;
}
/**
 * Settlement webhook object
 * @export
 * @interface SettlementWebhook
 */
export interface SettlementWebhook {
    /**
     *
     * @type {SettlementWebhookDataEntity}
     * @memberof SettlementWebhook
     */
    'data'?: SettlementWebhookDataEntity;
    /**
     *
     * @type {string}
     * @memberof SettlementWebhook
     */
    'event_time'?: string;
    /**
     *
     * @type {string}
     * @memberof SettlementWebhook
     */
    'type'?: string;
}
/**
 * data entity in webhook
 * @export
 * @interface SettlementWebhookDataEntity
 */
export interface SettlementWebhookDataEntity {
    /**
     *
     * @type {SettlementEntity}
     * @memberof SettlementWebhookDataEntity
     */
    'settlement'?: SettlementEntity;
}
/**
 * Use this if you are creating an order for cashfree\'s softPOS
 * @export
 * @interface TerminalDetails
 */
export interface TerminalDetails {
    /**
     * date time at which terminal is added
     * @type {string}
     * @memberof TerminalDetails
     */
    'added_on'?: string;
    /**
     * cashfree terminal id
     * @type {string}
     * @memberof TerminalDetails
     */
    'cf_terminal_id'?: string;
    /**
     * last instant when this terminal was updated
     * @type {string}
     * @memberof TerminalDetails
     */
    'last_updated_on'?: string;
    /**
     * location of terminal
     * @type {string}
     * @memberof TerminalDetails
     */
    'terminal_address'?: string;
    /**
     * terminal id for merchant reference
     * @type {string}
     * @memberof TerminalDetails
     */
    'terminal_id': string;
    /**
     * name of terminal/agent/storefront
     * @type {string}
     * @memberof TerminalDetails
     */
    'terminal_name'?: string;
    /**
     * note given by merchant while creating the terminal
     * @type {string}
     * @memberof TerminalDetails
     */
    'terminal_note'?: string;
    /**
     * mobile num of the terminal/agent/storefront
     * @type {string}
     * @memberof TerminalDetails
     */
    'terminal_phone_no': string;
    /**
     * status of terminal active/inactive
     * @type {string}
     * @memberof TerminalDetails
     */
    'terminal_status'?: string;
    /**
     * To identify the type of terminal product in use, in this case it is SPOS.
     * @type {string}
     * @memberof TerminalDetails
     */
    'terminal_type': string;
}
/**
 * Create terminal response object
 * @export
 * @interface TerminalEntity
 */
export interface TerminalEntity {
    /**
     *
     * @type {string}
     * @memberof TerminalEntity
     */
    'added_on'?: string;
    /**
     *
     * @type {number}
     * @memberof TerminalEntity
     */
    'cf_terminal_id'?: number;
    /**
     *
     * @type {string}
     * @memberof TerminalEntity
     */
    'last_updated_on'?: string;
    /**
     *
     * @type {string}
     * @memberof TerminalEntity
     */
    'terminal_address'?: string;
    /**
     *
     * @type {string}
     * @memberof TerminalEntity
     */
    'terminal_email'?: string;
    /**
     *
     * @type {string}
     * @memberof TerminalEntity
     */
    'terminal_type'?: string;
    /**
     *
     * @type {string}
     * @memberof TerminalEntity
     */
    'teminal_id'?: string;
    /**
     *
     * @type {string}
     * @memberof TerminalEntity
     */
    'terminal_name'?: string;
    /**
     *
     * @type {string}
     * @memberof TerminalEntity
     */
    'terminal_note'?: string;
    /**
     *
     * @type {string}
     * @memberof TerminalEntity
     */
    'terminal_phone_no'?: string;
    /**
     *
     * @type {string}
     * @memberof TerminalEntity
     */
    'terminal_status'?: string;
    /**
     *
     * @type {string}
     * @memberof TerminalEntity
     */
    'terminal_meta'?: string;
}
/**
 * Create terminal response object
 * @export
 * @interface TerminalTransactionEntity
 */
export interface TerminalTransactionEntity {
    /**
     *
     * @type {string}
     * @memberof TerminalTransactionEntity
     */
    'cf_payment_id'?: string;
    /**
     *
     * @type {number}
     * @memberof TerminalTransactionEntity
     */
    'payment_amount'?: number;
    /**
     *
     * @type {string}
     * @memberof TerminalTransactionEntity
     */
    'payment_method'?: string;
    /**
     *
     * @type {string}
     * @memberof TerminalTransactionEntity
     */
    'payment_url'?: string;
    /**
     *
     * @type {string}
     * @memberof TerminalTransactionEntity
     */
    'qrcode'?: string;
    /**
     *
     * @type {string}
     * @memberof TerminalTransactionEntity
     */
    'timeout'?: string;
}
/**
 * Request to terminate an active order at Cashfree
 * @export
 * @interface TerminateOrderRequest
 */
export interface TerminateOrderRequest {
    /**
     * To terminate an order, pass order_status as \"TERMINATE\". Please note, order might not be terminated - confirm with the order_status in response. \"TERMINATION_REQUESTED\" states that the request is recieved and we are working on it. If the order terminates successfully, status will change to \"TERMINATED\". Incase there\'s any active transaction which moved to success - order might not get terminated.
     * @type {string}
     * @memberof TerminateOrderRequest
     */
    'order_status': string;
}
/**
 * object when you are using preauth in UPI in order pay
 * @export
 * @interface UPIAuthorizeDetails
 */
export interface UPIAuthorizeDetails {
    /**
     * Time by which this authorization should be approved by the customer.
     * @type {string}
     * @memberof UPIAuthorizeDetails
     */
    'approve_by'?: string;
    /**
     * This is the time when the UPI one time mandate will start
     * @type {string}
     * @memberof UPIAuthorizeDetails
     */
    'start_time'?: string;
    /**
     * This is the time when the UPI mandate will be over. If the mandate has not been executed by this time, the funds will be returned back to the customer after this time.
     * @type {string}
     * @memberof UPIAuthorizeDetails
     */
    'end_time'?: string;
}
/**
 * Complete payment method for UPI collect
 * @export
 * @interface UPIPaymentMethod
 */
export interface UPIPaymentMethod {
    /**
     *
     * @type {Upi}
     * @memberof UPIPaymentMethod
     */
    'upi': Upi;
}
/**
 * Update terminal response
 * @export
 * @interface UpdateTerminalEntity
 */
export interface UpdateTerminalEntity {
    /**
     *
     * @type {string}
     * @memberof UpdateTerminalEntity
     */
    'added_on'?: string;
    /**
     *
     * @type {number}
     * @memberof UpdateTerminalEntity
     */
    'cf_terminal_id'?: number;
    /**
     *
     * @type {string}
     * @memberof UpdateTerminalEntity
     */
    'last_updated_on'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateTerminalEntity
     */
    'terminal_address'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateTerminalEntity
     */
    'terminal_email'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateTerminalEntity
     */
    'terminal_type'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateTerminalEntity
     */
    'teminal_id'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateTerminalEntity
     */
    'terminal_name'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateTerminalEntity
     */
    'terminal_note'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateTerminalEntity
     */
    'terminal_phone_no'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateTerminalEntity
     */
    'terminal_status'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateTerminalEntity
     */
    'terminal_meta'?: string;
}
/**
 * Request body to update terminal details.
 * @export
 * @interface UpdateTerminalRequest
 */
export interface UpdateTerminalRequest {
    /**
     * Mention the updated email ID of the terminal.
     * @type {string}
     * @memberof UpdateTerminalRequest
     */
    'terminal_email'?: string;
    /**
     * Terminal phone number to be updated.
     * @type {string}
     * @memberof UpdateTerminalRequest
     */
    'terminal_phone_no'?: string;
    /**
     *
     * @type {UpdateTerminalRequestTerminalMeta}
     * @memberof UpdateTerminalRequest
     */
    'terminal_meta'?: UpdateTerminalRequestTerminalMeta;
    /**
     * Mention the terminal type to be updated. Possible values - AGENT, STOREFRONT.
     * @type {string}
     * @memberof UpdateTerminalRequest
     */
    'terminal_type': string;
}
/**
 * Terminal metadata.
 * @export
 * @interface UpdateTerminalRequestTerminalMeta
 */
export interface UpdateTerminalRequestTerminalMeta {
    /**
     * Name of the operator for the storefront.
     * @type {string}
     * @memberof UpdateTerminalRequestTerminalMeta
     */
    'terminal_operator'?: string;
}
/**
 * Request body to update terminal status.
 * @export
 * @interface UpdateTerminalStatusRequest
 */
export interface UpdateTerminalStatusRequest {
    /**
     * Status of the terminal to be updated. possible values - ACTIVE, INACTIVE.
     * @type {string}
     * @memberof UpdateTerminalStatusRequest
     */
    'terminal_status': string;
}
/**
 * UPI collect payment method object
 * @export
 * @interface Upi
 */
export interface Upi {
    /**
     * Specify the channel through which the payment must be processed. Can be one of [\"link\", \"collect\", \"qrcode\"]
     * @type {string}
     * @memberof Upi
     */
    'channel': UpiChannelEnum;
    /**
     * Customer UPI VPA to process payment.  ### Important This is a required parameter for channel = `collect`
     * @type {string}
     * @memberof Upi
     */
    'upi_id'?: string;
    /**
     * use this if you want cashfree to show a loader. Sample response below. It is only supported for collect `action:collect` will be returned with `data.url` having the link for redirection
     * @type {boolean}
     * @memberof Upi
     */
    'upi_redirect_url'?: boolean;
    /**
     * The UPI request will be valid for this expiry minutes. This parameter is only applicable for a UPI collect payment. The default value is 5 minutes. You should keep the minimum as 5 minutes, and maximum as 15 minutes
     * @type {number}
     * @memberof Upi
     */
    'upi_expiry_minutes'?: number;
    /**
     * For one time mandate on UPI. Set this as authorize_only = true. Please note that you can only use the \"collect\" channel if you are sending a one time mandate request
     * @type {boolean}
     * @memberof Upi
     */
    'authorize_only'?: boolean;
    /**
     *
     * @type {UPIAuthorizeDetails}
     * @memberof Upi
     */
    'authorization'?: UPIAuthorizeDetails;
}
export declare const UpiChannelEnum: {
    readonly LINK: "link";
    readonly COLLECT: "collect";
    readonly QRCODE: "qrcode";
    readonly UNKNOWN_DEFAULT_OPEN_API: "11184809";
};
export type UpiChannelEnum = typeof UpiChannelEnum[keyof typeof UpiChannelEnum];
/**
 * Request body to upload terminal documents.
 * @export
 * @interface UploadTerminalDocs
 */
export interface UploadTerminalDocs {
    /**
     * Mention the document type you are uploading. Possible values - ADDRESSPROOF, PHOTOGRAPH.
     * @type {string}
     * @memberof UploadTerminalDocs
     */
    'doc_type': string;
    /**
     * Enter the display name of the uploaded file.
     * @type {string}
     * @memberof UploadTerminalDocs
     */
    'doc_value': string;
    /**
     * Select the document that should be uploaded or provide the path of that file. You cannot upload a file that is more than 2MB in size.
     * @type {string}
     * @memberof UploadTerminalDocs
     */
    'file': string;
}
/**
 * Upload the terminal documents.
 * @export
 * @interface UploadTerminalDocsEntity
 */
export interface UploadTerminalDocsEntity {
    /**
     *
     * @type {number}
     * @memberof UploadTerminalDocsEntity
     */
    'cf_terminal_id'?: number;
    /**
     *
     * @type {string}
     * @memberof UploadTerminalDocsEntity
     */
    'doc_type'?: string;
    /**
     *
     * @type {string}
     * @memberof UploadTerminalDocsEntity
     */
    'doc_value'?: string;
    /**
     *
     * @type {string}
     * @memberof UploadTerminalDocsEntity
     */
    'status'?: string;
}
/**
 * Use to split order when cashfree\'s Easy Split is enabled for your account.
 * @export
 * @interface VendorSplit
 */
export interface VendorSplit {
    /**
     * Vendor id created in Cashfree system
     * @type {string}
     * @memberof VendorSplit
     */
    'vendor_id'?: string;
    /**
     * Amount which will be associated with this vendor
     * @type {number}
     * @memberof VendorSplit
     */
    'amount'?: number;
    /**
     * Percentage of order amount which shall get added to vendor account
     * @type {number}
     * @memberof VendorSplit
     */
    'percentage'?: number;
}
/**
 *
 * @export
 * @interface WalletOffer
 */
export interface WalletOffer {
    /**
     *
     * @type {string}
     * @memberof WalletOffer
     */
    'provider'?: string;
}
/**
 * TokenVaultApi - object-oriented interface
 * @export
 * @class TokenVaultApi
 * @extends {BaseAPI}
 */
/**
 * @export
 */
export declare const PGCustomerFetchInstrumentsInstrumentTypeEnum: {
    readonly CARD: "card";
    readonly UNKNOWN_DEFAULT_OPEN_API: "11184809";
};
export type PGCustomerFetchInstrumentsInstrumentTypeEnum = typeof PGCustomerFetchInstrumentsInstrumentTypeEnum[keyof typeof PGCustomerFetchInstrumentsInstrumentTypeEnum];
declare class Environment {
    PRODUCTION: CFEnvironment;
    SANDBOX: CFEnvironment;
}
export declare class PGWebhookEvent {
    type: string;
    raw: string;
    object: any;
    constructor(type: string, rawBody: string, object: any);
}
export declare class Cashfree {
    static axios: AxiosInstance;
    static basePath: string;
    static XClientId?: string;
    static XClientSecret?: string;
    static XPartnerKey?: string;
    static XClientSignature?: string;
    static XPartnerMerchantId?: string;
    static XEnvironment: CFEnvironment;
    static XEnableErrorAnalytics: boolean;
    static XApiVersion: string;
    static Environment: Environment;
    /**
     * Use this API to verify your webhook signature once you receive from Cashfree's server.
     * @summary Verify Webhook Signatures
     * @param {string} signature that is present in the header of the webhook ("x-webhook-signature")
     * @param {string} rawBody is the entire body sent to the server in string format
     * @param {string} timestamp that is present in the header of the webhook ("x-webhook-timestamp")
     * @throws {Error}
     */
    static PGVerifyWebhookSignature(signature: string, rawBody: string, timestamp: string): PGWebhookEvent;
    /**
     * Create Customer at Cashfree
     * @summary Create Customer at Cashfree
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {CreateCustomerRequest} CreateCustomerRequest Request to create a new customer at Cashfree
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    static PGCreateCustomer(x_api_version: string, CreateCustomerRequest: CreateCustomerRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<CustomerEntity, any>>;
    /**
     * Use this API to get eligible Cardless EMI Payment Methods available for a customer on an order basis their phone number.
     * @summary Get Eligible Cardless EMI Payment Methods for a customer on an order
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {EligibilityFetchCardlessEMIRequest} EligibilityFetchCardlessEMIRequest Request Body to get eligible cardless emi options for a customer and order
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EligibilityApi
     */
    static PGEligibilityFetchCardlessEMI(x_api_version: string, EligibilityFetchCardlessEMIRequest: EligibilityFetchCardlessEMIRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<EligibilityCardlessEMIEntity[], any>>;
    /**
     * Use this API to get eligible offers for an order_id or order amount.
     * @summary Get Eligible Offers for an Order
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {EligibilityFetchOffersRequest} EligibilityFetchOffersRequest Request Body to get eligible offers for a customer and order
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EligibilityApi
     */
    static PGEligibilityFetchOffers(x_api_version: string, EligibilityFetchOffersRequest: EligibilityFetchOffersRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<EligibilityOfferEntity[], any>>;
    /**
     * Use this API to get eligible Paylater Payment Methods for a customer on an order.
     * @summary Get Eligible Paylater for a customer on an order
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {EligibilityFetchPaylaterRequest} EligibilityFetchPaylaterRequest Request Body to get eligible paylater options for a customer and order
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EligibilityApi
     */
    static PGEligibilityFetchPaylater(x_api_version: string, EligibilityFetchPaylaterRequest: EligibilityFetchPaylaterRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<EligibilityPaylaterEntity[], any>>;
    /**
     * Use this API to get eligible Payment Methods
     * @summary Get eligible Payment Methods
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {EligibilityFetchPaymentMethodsRequest} EligibilityFetchPaymentMethodsRequest Request Body to get eligible payment methods for an account and order
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EligibilityApi
     */
    static PGEligibilityFetchPaymentMethods(x_api_version: string, EligibilityFetchPaymentMethodsRequest: EligibilityFetchPaymentMethodsRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<EligibilityPaymentMethodsEntity[], any>>;
    /**
     * Use this API to create offers with Cashfree from your backend
     * @summary Create Offer
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {CreateOfferRequest} CreateOfferRequest Request body to create an offer at Cashfree
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OffersApi
     */
    static PGCreateOffer(x_api_version: string, CreateOfferRequest: CreateOfferRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<OfferEntity, any>>;
    /**
     * Use this API to get offer by offer_id
     * @summary Get Offer by ID
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} offer_id The offer ID for which you want to view the offer details.
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OffersApi
     */
    static PGFetchOffer(x_api_version: string, offer_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<OfferEntity, any>>;
    /**
     * ### Order An order is an entity which has a amount and currency associated with it. It is something for which you want to collect payment for. Use this API to create orders with Cashfree from your backend to get a `payment_sessions_id`.  You can use the `payment_sessions_id` to create a transaction for the order.
     * @summary Create Order
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {CreateOrderRequest} CreateOrderRequest Request body to create an order at cashfree
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    static PGCreateOrder(x_api_version: string, CreateOrderRequest: CreateOrderRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<OrderEntity, any>>;
    /**
     * Use this API to fetch the order that was created at Cashfree\'s using the `order_id`.  ## When to use this API - To check the status of your order - Once the order is PAID - Once your customer returns to `return_url`
     * @summary Get Order
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} order_id The id which uniquely identifies your order
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    static PGFetchOrder(x_api_version: string, order_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<OrderEntity, any>>;
    /**
     * Use this API to terminate the order that was created at Cashfree\'s using the `order_id`.
     * @summary Terminate Order
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} order_id The id which uniquely identifies your order
     * @param {TerminateOrderRequest} TerminateOrderRequest Request body to terminate an order at cashfree
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    static PGTerminateOrder(x_api_version: string, order_id: string, TerminateOrderRequest: TerminateOrderRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<OrderEntity, any>>;
    /**
     * - Use this API to get the payment gateway reconciliation details with date range. - It will have events for your payment account
     * @summary PG Reconciliation
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {FetchReconRequest} FetchReconRequest Request Body for the reconciliation
     * @param {string} [Content_Type] application/json
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.
     * @param {string} [Accept] application/json
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PGReconciliationApi
     */
    static PGFetchRecon(x_api_version: string, FetchReconRequest: FetchReconRequest, Content_Type?: string, x_request_id?: string, x_idempotency_key?: string, Accept?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ReconEntity, any>>;
    /**
     * Use this API to cancel a payment link. No further payments can be done against a cancelled link. Only a link in ACTIVE status can be cancelled.
     * @summary Cancel Payment Link
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} link_id The payment link ID for which you want to view the details.
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentLinksApi
     */
    static PGCancelLink(x_api_version: string, link_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<LinkEntity, any>>;
    /**
     * Use this API to create a new payment link. The created payment link url will be available in the API response parameter link_url.
     * @summary Create Payment Link
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {CreateLinkRequest} CreateLinkRequest Request Body to Create Payment Links
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentLinksApi
     */
    static PGCreateLink(x_api_version: string, CreateLinkRequest: CreateLinkRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<LinkEntity, any>>;
    /**
     * Use this API to view all details and status of a payment link.
     * @summary Fetch Payment Link Details
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} link_id The payment link ID for which you want to view the details.
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentLinksApi
     */
    static PGFetchLink(x_api_version: string, link_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<LinkEntity, any>>;
    /**
     * Use this API to view all order details for a payment link.
     * @summary Get Orders for a Payment Link
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} link_id The payment link ID for which you want to view the details.
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentLinksApi
     */
    static PGLinkFetchOrders(x_api_version: string, link_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PaymentLinkOrderEntity[], any>>;
    /**
     * Use this API to capture or void a preauthorized payment
     * @summary Preauthorization
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} order_id The id which uniquely identifies your order
     * @param {AuthorizeOrderRequest} AuthorizeOrderRequest Request to Capture or Void Transactions
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    static PGAuthorizeOrder(x_api_version: string, order_id: string, AuthorizeOrderRequest: AuthorizeOrderRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PaymentEntity, any>>;
    /**
     * If you accept OTP on your own page, you can use the below API to send OTP to Cashfree.
     * @summary Submit or Resend OTP
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} cf_payment_id The Cashfree payment or transaction ID.
     * @param {OrderAuthenticatePaymentRequest} OrderAuthenticatePaymentRequest Request body to submit/resend headless OTP. To use this API make sure you have headless OTP enabled for your account
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    static PGOrderAuthenticatePayment(x_api_version: string, cf_payment_id: string, OrderAuthenticatePaymentRequest: OrderAuthenticatePaymentRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<OrderAuthenticateEntity, any>>;
    /**
     * Use this API to view payment details of an order for a payment ID.
     * @summary Get Payment by ID
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} order_id The id which uniquely identifies your order
     * @param {string} cf_payment_id The Cashfree payment or transaction ID.
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    static PGOrderFetchPayment(x_api_version: string, order_id: string, cf_payment_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PaymentEntity, any>>;
    /**
     * Use this API to view all payment details for an order.
     * @summary Get Payments for an Order
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} order_id The id which uniquely identifies your order
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    static PGOrderFetchPayments(x_api_version: string, order_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PaymentEntity[], any>>;
    /**
     * Use this API when you have already created the orders and want Cashfree to process the payment. To use this API S2S flag needs to be enabled from the backend. In case you want to use the cards payment option the PCI DSS flag is required, for more information send an email to \"care@cashfree.com\".
     * @summary Order Pay
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {PayOrderRequest} PayOrderRequest Request body to create a transaction at cashfree using &#x60;payment_session_id&#x60;
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    static PGPayOrder(x_api_version: string, PayOrderRequest: PayOrderRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PayOrderEntity, any>>;
    /**
     * Use this API to initiate refunds.
     * @summary Create Refund
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} order_id The id which uniquely identifies your order
     * @param {OrderCreateRefundRequest} OrderCreateRefundRequest Request Body to Create Refunds
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundsApi
     */
    static PGOrderCreateRefund(x_api_version: string, order_id: string, OrderCreateRefundRequest: OrderCreateRefundRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<RefundEntity, any>>;
    /**
     * Use this API to fetch a specific refund processed on your Cashfree Account.
     * @summary Get Refund
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} order_id The id which uniquely identifies your order
     * @param {string} refund_id Refund Id of the refund you want to fetch.
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundsApi
     */
    static PGOrderFetchRefund(x_api_version: string, order_id: string, refund_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<RefundEntity, any>>;
    /**
     * Use this API to fetch all refunds processed against an order.
     * @summary Get All Refunds for an Order
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} order_id The id which uniquely identifies your order
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundsApi
     */
    static PGOrderFetchRefunds(x_api_version: string, order_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<RefundEntity[], any>>;
    /**
     * Use this API to get all settlement details by specifying the settlement ID, settlement UTR or date range.
     * @summary Get All Settlements
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {FetchSettlementsRequest} FetchSettlementsRequest Request Body to get the settlements
     * @param {string} [Content_Type] application/json
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.
     * @param {string} [Accept] application/json
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettlementReconciliationApi
     */
    static PGFetchSettlements(x_api_version: string, FetchSettlementsRequest: FetchSettlementsRequest, Content_Type?: string, x_request_id?: string, x_idempotency_key?: string, Accept?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<SettlementEntity, any>>;
    /**
     * - Use this API to get settlement reconciliation details using Settlement ID, settlement UTR or date range. - This API will return events for the settlement IDs you want
     * @summary Settlement Reconciliation
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {SettlementFetchReconRequest} SettlementFetchReconRequest Request Body for the settlement reconciliation
     * @param {string} [Content_Type] application/json
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.
     * @param {string} [Accept] application/json
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettlementReconciliationApi
     */
    static PGSettlementFetchRecon(x_api_version: string, SettlementFetchReconRequest: SettlementFetchReconRequest, Content_Type?: string, x_request_id?: string, x_idempotency_key?: string, Accept?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<SettlementReconEntity, any>>;
    /**
     * Use this API to view all the settlements of a particular order.
     * @summary Get Settlements by Order ID
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} order_id The id which uniquely identifies your order
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettlementsApi
     */
    static PGOrderFetchSettlement(x_api_version: string, order_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<SettlementEntity, any>>;
    /**
     * Use this API to create new terminals to use softPOS.
     * @summary Create Terminal
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {CreateTerminalRequest} CreateTerminalRequest Request Body to Create Terminal for SPOS
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoftPOSApi
     */
    static SposCreateTerminal(x_api_version: string, CreateTerminalRequest: CreateTerminalRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<TerminalEntity, any>>;
    /**
     * Use this API to create a new terminal transaction. To use this API you should first create an order using the Create Order API. Also, you need to enter the terminal details while creating the order and pass the same terminal information while creating a transaction using the below mentioned API.
     * @summary Create Terminal Transaction
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {CreateTerminalTransactionRequest} CreateTerminalTransactionRequest Request body to create a terminal transaction
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoftPOSApi
     */
    static SposCreateTerminalTransaction(x_api_version: string, CreateTerminalTransactionRequest: CreateTerminalTransactionRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<TerminalTransactionEntity, any>>;
    /**
     * Use this API to view all details of a terminal.
     * @summary Get Terminal Status using Phone Number
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} terminal_phone_no The terminal for which you want to view the order details.
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoftPOSApi
     */
    static SposFetchTerminal(x_api_version: string, terminal_phone_no: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<TerminalEntity, any>>;
    /**
     * You can fetch all the StaticQRs corresponding to given terminal id or phone number. Provide either the terminal_phone_no or terminal_id in the request.
     * @summary Fetch Terminal QR Codes
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} terminal_phone_no Phone number assigned to the terminal. Required if you are not providing the cf_terminal_id in the request.
     * @param {string} cf_terminal_id Cashfree terminal id for which you want to get staticQRs. Required if you are not providing the terminal_phone_number in the request.
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoftPOSApi
     */
    static SposFetchTerminalQRCodes(x_api_version: string, terminal_phone_no: string, cf_terminal_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<FetchTerminalQRCodesEntity[], any>>;
    /**
     * Use this API to update the terminal details. Email, Phone Number, and Terminal Meta are updatable for \"Storefront\". Only account status change is possible in case of \"Agent\".
     * @summary Update Terminal
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} cf_terminal_id Provide the Cashfree terminal ID for which the details have to be updated.
     * @param {UpdateTerminalRequest} UpdateTerminalRequest Request Body to update terminal for SPOS.
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoftPOSApi
     */
    static SposUpdateTerminal(x_api_version: string, cf_terminal_id: string, UpdateTerminalRequest: UpdateTerminalRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<UpdateTerminalEntity[], any>>;
    /**
     * Use this API to update the terminal status.
     * @summary Update Terminal Sttus
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} cf_terminal_id Provide the Cashfree terminal ID for which the details have to be updated.
     * @param {UpdateTerminalStatusRequest} UpdateTerminalStatusRequest Request Body to update terminal status for SPOS.
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoftPOSApi
     */
    static SposUpdateTerminalStatus(x_api_version: string, cf_terminal_id: string, UpdateTerminalStatusRequest: UpdateTerminalStatusRequest, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<UpdateTerminalEntity[], any>>;
    /**
     * Use this API to upload the terminal documents.
     * @summary Upload Terminal Docs
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} cf_terminal_id Provide the Cashfree terminal ID for which the details have to be updated.
     * @param {UploadTerminalDocs} UploadTerminalDocs Request Body to update terminal documents for SPOS.
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoftPOSApi
     */
    static SposUploadTerminalDocs(x_api_version: string, cf_terminal_id: string, UploadTerminalDocs: UploadTerminalDocs, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<UploadTerminalDocsEntity[], any>>;
    /**
     * Use this API to delete a saved card instrument for a customer_id and instrument_id
     * @summary Delete Saved Card Instrument
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} customer_id Your Customer ID that you had sent during create order API &#x60;POST/orders&#x60;
     * @param {string} instrument_id The instrument_id which needs to be deleted
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenVaultApi
     */
    static PGCustomerDeleteInstrument(x_api_version: string, customer_id: string, instrument_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<InstrumentEntity, any>>;
    /**
     * Use this API to fetch a single specific saved card for a customer_id by it\'s instrument_id
     * @summary Fetch Specific Saved Card Instrument
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} customer_id Your Customer ID that you had sent during create order API &#x60;POST/orders&#x60;
     * @param {string} instrument_id The instrument_id of the saved instrument which needs to be queried
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenVaultApi
     */
    static PGCustomerFetchInstrument(x_api_version: string, customer_id: string, instrument_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<InstrumentEntity, any>>;
    /**
     * Use this API to fetch saved cards for a customer_id
     * @summary Fetch All Saved Card Instrument
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} customer_id Your Customer ID that you had sent during create order API &#x60;POST/orders&#x60;
     * @param {PGCustomerFetchInstrumentsInstrumentTypeEnum} instrument_type Payment mode or type of saved instrument
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenVaultApi
     */
    static PGCustomerFetchInstruments(x_api_version: string, customer_id: string, instrument_type: PGCustomerFetchInstrumentsInstrumentTypeEnum, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<InstrumentEntity[], any>>;
    /**
     * Use this API To get the card network token, token expiry and cryptogram for a saved card instrument using instrument id
     * @summary Fetch cryptogram for a saved card instrument
     * @param {string} x_api_version API version to be used. Format is in YYYY-MM-DD
     * @param {string} customer_id Your Customer ID that you had sent during create order API &#x60;POST/orders&#x60;
     * @param {string} instrument_id The instrument_id of the saved card instrument which needs to be queried
     * @param {string} [x_request_id] Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param {string} [x_idempotency_key] An idempotency key is a unique identifier you include with your API call. If the request fails or times out, you can safely retry it using the same key to avoid duplicate actions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenVaultApi
     */
    static PGCustomerInstrumentsFetchCryptogram(x_api_version: string, customer_id: string, instrument_id: string, x_request_id?: string, x_idempotency_key?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<CryptogramEntity, any>>;
}
export {};
